<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Iván Arribas (Depto. Análisis Económico. Universitat de València)" />


<title>Procesos ARIMA</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
#rmd-source-code {
  display: none;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-inverse  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Predicción con Datos Temporales</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="01-Guia-curso.html">
    <span class="fa fa-graduation-cap"></span>
     
    Guía del curso
  </a>
</li>
<li>
  <a href="02-Logistica.html">
    <span class="fa fa-laptop"></span>
     
    Logística
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-book"></span>
     
    Diapos
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Teoría</li>
    <li>
      <a href="03-01-Tema1.html">Tema 1: Introducción</a>
    </li>
    <li>
      <a href="03-02-Tema2.html">Tema 2: Definición</a>
    </li>
    <li>
      <a href="03-03-Tema3.html">Tema 3: Métodos sencillos</a>
    </li>
    <li>
      <a href="03-04-Tema4.html">Tema 4: Media móvil</a>
    </li>
    <li>
      <a href="03-05-Tema5.html">Tema 5: Alisado</a>
    </li>
    <li>
      <a href="03-06-Tema6.html">Tema 6: ARIMA</a>
    </li>
    <li>
      <a href="03-07-Tema7.html">Tema 7: SARIMA</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Ejemplo de aplicación</li>
    <li>
      <a href="03-08-Ejemplo2.html">Ejemplo Tema 2</a>
    </li>
    <li>
      <a href="03-09-Ejemplo3.html">Ejemplo Tema 3</a>
    </li>
    <li>
      <a href="03-10-Ejemplo4.html">Ejemplo Tema 4</a>
    </li>
    <li>
      <a href="03-11-Ejemplo5.html">Ejemplo Tema 5</a>
    </li>
    <li>
      <a href="03-12-Ejemplo6.html">Ejemplo Tema 6</a>
    </li>
    <li>
      <a href="03-13-Ejemplo7.html">Ejemplo Tema 7</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Otro ejemplo</li>
    <li>
      <a href="03-14-Ejemplo-Pasajeros.html">Ejemplo de Pasajeros</a>
    </li>
  </ul>
</li>
<li>
  <a href="04-Recursos-R.html">
    <span class="fa fa-code"></span>
     
    Recursos de R
  </a>
</li>
<li>
  <a href="05-Practica.html">
    <span class="fa fa-edit"></span>
     
    Practica
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    <span class="fa fa-download"></span>
     
    Más
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">R</li>
    <li>
      <a href="https://cran.r-project.org">Dónde está R</a>
    </li>
    <li>
      <a href="https://rstudio.com">Donde está RStudio</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Markdown</li>
    <li>
      <a href="https://bookdown.org/yihui/rmarkdown/">Markdown</a>
    </li>
    <li>
      <a href="https://rmarkdown.rstudio.com/lesson-1.html">R Markdown</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Otros</li>
    <li>
      <a href="https://www.r-bloggers.com">Blog sobre R</a>
    </li>
    <li>
      <a href="https://bookdown.org">Libros online que debes conocer</a>
    </li>
  </ul>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Procesos ARIMA</h1>
<h3 class="subtitle">Previsión con Datos Temporales (GBIA)</h3>
<h4 class="author">Iván Arribas (Depto. Análisis Económico. Universitat de València)</h4>
<h4 class="date">Curso 2020-21</h4>

</div>


<div id="introducción" class="section level1">
<h1><span class="header-section-number">1</span> Introducción</h1>
<p>Los <strong>modelos ARIMA</strong> han mostrado ser uno se los métodos de ajuste de series temporales más valiosos desde que fueran formalizados en 1976 por Box y Jenkins, en su libro <a href="http://www.amazon.com/Time-Analysis-Forecasting-George-Box/dp/0470272848"><em>Time series analysis, forecasting and control</em></a>. Además, dieron las pautas a seguir en el ajuste de una serie temporal para alcanzar buenas predicciones (véase epígrafe 6).</p>
<p>En este tema, y el siguiente, definiremos estos procesos y aprenderemos a identificarlos, estimarlos y hacer predicciones.</p>
<p><strong>Los procesos ARIMA son ahora el tronco de una amplia familia de procesos</strong> que requieren menos hipótesis para su aplicación o ajustan mejor bajo diferentes hipótesis: ARCH, GARCH, NGARCH, IGARCH, EGARCH, GARCH-M, QGARCH, GJR-GARCH, TGARCH, fGARCH…</p>
<p><strong>Los procesos ARIMA y los métodos de Alisado Exponencial son complementarios</strong>:</p>
<ul>
<li>Los modelos de Alisado lineales son casos especiales de modelos Arima,</li>
<li>Los modelos de Alisado no lineales no tienen su contrapartida en modelos Arima</li>
<li>Muchos modelos Arima no tiene contrapartida en los modelos de Alisado.</li>
</ul>
<p>Pero antes de entrar en materia es necesario definir una serie de conceptos que permitirán entender mejor <strong>una serie temporal como una muestra de un proceso generador de datos</strong> (PGD).</p>
<p><br />
<br />
</p>
</div>
<div id="proceso-estocástico" class="section level1">
<h1><span class="header-section-number">2</span> Proceso estocástico</h1>
<p><br />
</p>
<div id="definición-e-hipótesis-sobre-el-proceso" class="section level2">
<h2><span class="header-section-number">2.1</span> Definición e hipótesis sobre el proceso</h2>
<p>Un <strong>proceso estocástico</strong> <span class="math inline">\(Y_t\)</span> es (sin excesiva precisión) una variable aleatoria que corresponde a momentos sucesivos del tiempo. A diferencia de los temas previos, en este vamos a estimar modelos sobre procesos estocásticos. Sería el equivalente para series temporales al modelo de regresión lineal que viste en el primer semestre para datos transversales.</p>
<p>Al igual que en <em>Predicción con datos transversales</em>, la aplicación de estos modelos requiere del cumplimiento de una serie de hipótesis. Para el caso de series temporales el proceso debe ser <strong>normal</strong>, <strong>estacionario</strong> y <strong>ergódico</strong>.</p>
<p><br />
</p>
<div id="proceso-estacionario" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Proceso estacionario</h3>
<p>Un proceso es <strong>estacionario en sentido estricto</strong> cuando la distribución conjunta no varía al realizar un desplazamiento en el tiempo de todas las variables.</p>
<ul>
<li>Si <span class="math inline">\(F(Y_{t_1},..., Y_{t_k})\)</span> es la función de distribución conjunta y <span class="math inline">\(h&gt;0\)</span>, entonces el proceso es estacionario en sentido estricto si <span class="math display">\[F(Y_{t_1},..., Y_{t_k}) = F(Y_{t_1+h},..., Y_{t_k+h})\]</span></li>
</ul>
<p>Intuitivamente, <em>la distribución de un proceso estocástico es independiente del momento del tiempo</em>.</p>
<p>Comprobar si un proceso es estacionario en sentido estricto es muy difícil, así que vamos a encontrar condiciones suficientes: <em>estacionariedad en media</em> y en <em>sentido amplio</em> (covarianza). <strong>Bajo normalidad</strong> un proceso estacionario en sentido amplio también lo será en sentido estricto.</p>
<p><strong>Proceso estacionario en media</strong></p>
<p>Un proceso es estacionario en media (o de primer orden) si su nivel se mantiene en el tiempo: <span class="math display">\[E[Y_t] = \mu \; \; \forall t\]</span></p>
<p><strong>Proceso estacionario en sentido amplio</strong></p>
<p>Un proceso (ya estacionario en media) es estacionario en sentido amplio, o de segundo orden, si sus momentos de orden dos no dependen del tiempo:</p>
<ul>
<li>La (auto)covarianza entre dos periodos de tiempo es finita y sólo depende del intervalo de tiempo transcurrido entre estos dos periodos: <span class="math display">\[Cov[Y_t, Y_{t+k}] = E[(Y_t - \mu)(Y_{t+k} - \mu)] = \gamma_k,\,\,\,\forall t\]</span></li>
</ul>
<p>Observa que la varianza será entonces <span class="math inline">\(Var[Y_t] = E[(Y_t - \mu)^2] = \gamma_0\)</span>.</p>
<p><br />
</p>
<p>La figura 1 muestra la serie Nacimientos que no es estacionaria ni en media, ni en varianza. No lo es en media por que presenta largos periodos de tendencia creciente y decreciente; y no lo es en varianza por que al inicio de la serie los datos presentna más variabilidad que a finales del siglo pasado.</p>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-1-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><strong>Proceso ergódico</strong></p>
<p>Para que un proceso sea ergódico las observaciones nuevas tienen que aportar suficiente información para que la varianza del valor medio converja a 0. Esto no ocurre si la dependencia entre las variables es muy fuerte.</p>
<p>Una condición necesaria pero no suficiente para que un proceso estacionario sea ergódico es: <span class="math display">\[\lim_{k\rightarrow \infty} \gamma_k = 0.\]</span></p>
<p><br />
<br />
</p>
</div>
</div>
</div>
<div id="transformaciones-de-una-serie" class="section level1">
<h1><span class="header-section-number">3</span> Transformaciones de una serie</h1>
<p><br />
</p>
<div id="ideas-generales" class="section level2">
<h2><span class="header-section-number">3.1</span> Ideas generales</h2>
<p>Una serie temporal <span class="math inline">\(\{y_t\}_{t=1}^T\)</span> no tiene porque verificar las condiciones de estacionariedad y ergodicidad. A continuación, veremos una serie de transformaciones que convierten una serie no estacionaria en estacionaria; no ergódica en ergódica; y, de paso, facilitan la verificación de la hipótesis de normalidad, que dejaremos para más adelante.</p>
<p>En el panel superior de la figura 2 vuelves a tener la serie de nacimientos, que denominaremos <span class="math inline">\(y_t\)</span>, y en panel inferior tienes la diferencia de la transformación logarítmica de la serie, <span class="math inline">\(log(y_t) - log(y_{t-1})\)</span>. La serie nacimientos no es estacionaria en media ni en varianza, pero la transformación logarítmica y la diferencia han logrado que sea estacionaria en ambos sentidos.</p>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-2-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
</p>
</div>
<div id="diferenciación" class="section level2">
<h2><span class="header-section-number">3.2</span> Diferenciación</h2>
<p><strong>La diferenciación permite transformar una serie no estacionaria en media en estacionaria en media</strong>.</p>
<p>Diferenciar de orden <span class="math inline">\(k\)</span> consiste en restar a la observación de un periodo la de <span class="math inline">\(k\)</span> periodos antes: <span class="math display">\[\nabla_k y_t = y_t - y_{t-k}.\]</span></p>
<div id="diferenciación-regular-k1" class="section level3 unnumbered">
<h3>Diferenciación regular (<span class="math inline">\(k=1\)</span>)</h3>
<p>Un caso concreto es la <strong>diferenciación regular o diferenciación de orden uno</strong>, que consiste en restar a la observación de un periodo la del periodo precedente: <span class="math display">\[\nabla y_t = y_t - y_{t-1}.\]</span></p>
<p>Si <span class="math inline">\(\nabla y_t\)</span> no fuera estacionaria, se diferenciaría (regularmente) una segunda vez para obtener una doble diferenciación de primer orden: <span class="math display">\[\nabla^{2} y_t = \nabla(\nabla y_t) = \nabla y_t - \nabla y_{t-1} = (y_t - y_{t-1}) - (y_{t-1} - y_{t-2}) = y_t - 2y_{t-1} + y_{t-2}\]</span></p>
<p>En la práctica una sola diferenciación suele ser suficiente para obtener la estacionariedad en media; diferenciar dos veces es excepcional; y diferenciar tres o más veces no se da.</p>
</div>
<div id="diferenciación-estacional-km" class="section level3 unnumbered">
<h3>Diferenciación estacional (<span class="math inline">\(k=m\)</span>)</h3>
<p>Existe la <strong>diferencia estacional</strong>, que consiste en restar a la observación de un periodo la observación precedente de la misma estación. Si el orden estacional es <span class="math inline">\(m\)</span>, entonces la diferencia estacional de <span class="math inline">\(y_t\)</span> es <span class="math display">\[\nabla_m y_t = y_t - y_{t-m}.\]</span> Una serie no estacionaria en media puede pasar a serlo tras diferenciarla estacionalmente. Es decir, cualquiera de las dos diferenciaciones (regular o estacional) o ambas a la vez son alternativas para obtener la estacionariedad en media.</p>
<p>Además, <strong>la diferenciación (regular, estacional o ambas) también permite alcanzar la ergodicidad</strong>.</p>
<p>La figura 3 muestra un ejemplo de diferenciación regular y/o estacional. En el primer panel aparece la serie original Nacimientos <span class="math inline">\(y_t\)</span>; el segundo panel muestra la serie diferenciada regularmente <span class="math inline">\(\nabla y_t\)</span>; en el tercer panel la serie diferenciada estacionalmente <span class="math inline">\(\nabla_m y_t\)</span>; y en el cuarto panel muestra la serie diferenciada regular y estacionalmente <span class="math inline">\(\nabla\nabla_m y_t\)</span>.</p>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-3-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><em>¿Qué transformación para nacimientos consideras que genera una serie estacionaria, tanto en media como en varianza?</em> Siempre hay un cierto grado de subjetividad en la elección de las diferencias que hay que aplicar a una serie. En la figura 3 podemos considerar que la diferenciación regular (panel 2) es suficiente para lograr la estacionariedad en media y en varianza y terminar el proceso de diferenciación. Pero también podemos considerar que la serie es estacionaria en media pero no lo suficiente en varianza, y optar por la doble diferenciación, regular y estacional (panel 4).</p>
</div>
<div id="diferenciación-con-r" class="section level3 unnumbered">
<h3>Diferenciación con <code>R</code></h3>
<p><code>R</code> dispone de la función <code>diff</code> para diferenciar una serie:</p>
<ul>
<li><code>diff(x)</code> calcula la diferencia regular o de orden <span class="math inline">\(1\)</span>, <span class="math inline">\(\nabla y_t\)</span></li>
<li><code>diff(x, lag = k)</code> calcula la diferencia de orden <span class="math inline">\(k\)</span>, <span class="math inline">\(\nabla_k y_t\)</span></li>
<li><code>diff(x, lag = k, difference = d)</code> calcula <span class="math inline">\(d\)</span> diferencias de orden <span class="math inline">\(k\)</span>, <span class="math inline">\(\nabla_k^d y_t\)</span></li>
</ul>
<p>Si necesitas calcular una diferencia regular y otra estacional, <span class="math inline">\(\nabla\nabla_m y_t\)</span>, debes usar <code>diff(diff(x, lag = m))</code>. El orden de las diferenciaciones no cambia el resultado.</p>
<p>Además, en <code>forecast</code> está disponible las funciones <code>ndiffs</code> y <code>nsdiffs</code> que estiman el número de diferencias regulares y estacionales, respectivamente, necesarias para que una serie sea estacionaria. Para la primera usa un contraste de raíces unitarias (que no veremos en este curso) y para la segunda un criterio <em>ad-hoc</em>.</p>
</div>
<div id="operador-retardo" class="section level3 unnumbered">
<h3>Operador Retardo</h3>
<p>Definimos el <strong>operador retardo</strong> <span class="math inline">\(L\)</span> como <span class="math inline">\(Ly_t = y_{t-1}\)</span>, es decir, retrasa un periodo la serie. En inglés se denomina <em>lag operator</em> (L) o <em>backward shift</em> (B)</p>
<p>Así, se tiene que <span class="math display">\[L^k y_t = y_{t-k}\]</span> y por tanto que <span class="math display">\[
\begin{aligned}
  \nabla y_t &amp; = y_t - y_{t-1} = y_t - Ly_t = (1-L)y_t \\
  \nabla^d y_t &amp; = (1-L)^d y_t \\
  \nabla_m y_t &amp; = (1-L^m) y_t
\end{aligned}
\]</span></p>
La siguiente tabla muestra un sencillo ejemplo del efecto del operador retardo sobre la serie <span class="math inline">\(y_t\)</span>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th align="right">y</th>
<th align="right">lag1_y</th>
<th align="right">lag2_y</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">NA</td>
<td align="right">NA</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">1</td>
<td align="right">NA</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">2</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">4</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="right">5</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="right">7</td>
<td align="right">6</td>
<td align="right">5</td>
</tr>
</tbody>
</table>
</div>
<p><br />
</p>
</div>
</div>
<div id="transformación-logarítmica" class="section level2">
<h2><span class="header-section-number">3.3</span> Transformación logarítmica</h2>
<p>Si la serie original no es estacionaria en varianza porque los datos crecen con el nivel de la serie, es posible obtener la estacionariedad por medio de transformaciones simples.</p>
<p>La transformación logarítmica de una serie es una alternativa. La figura 4 muestra la serie Nacimientos y su logaritmo. La variabilidad estacional con la transformación logarítmica (panel inferior) es menor que en la serie original (panel superior).</p>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-5-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><strong>Nota:</strong> la transformación logarítmica es un caso concreto de otra más general, la transformación de Box-Cox que no veremos en este curso: <span class="math display">\[
z_t = 
    \begin{cases}
      (y_t^{\lambda}-1)/\lambda &amp; \,\,\,\lambda \neq 0 \\
      \log(y_t) &amp; \,\,\, \lambda = 0 
    \end{cases}
\]</span></p>
<p>Se puede demostrar que <span class="math inline">\(\lim_{\lambda \rightarrow 0} \;\; (y_t^{\lambda}-1)/\lambda = log(y_t)\)</span>.</p>
<p><br />
</p>
</div>
<div id="diferencia-logaritmo-y-tasa-de-variación" class="section level2">
<h2><span class="header-section-number">3.4</span> Diferencia, Logaritmo y Tasa de variación</h2>
<p>La transformación <span class="math inline">\(\nabla y_t\)</span> se puede interpretar como variaciones en nivel, pero <span class="math inline">\(\nabla^2 y_t\)</span> no tiene ninguna interpretación. <strong>No conviene perder de vista la interpretabilidad de las observaciones</strong>.</p>
<p>Cuando una serie tiene que ser diferenciada dos veces para conseguir su estacionariedad, vale la pena probar una transformación alternativa que sea interpretable: <span class="math inline">\(\nabla \log(y_t)\)</span> o <span class="math inline">\(\nabla_m \log(y_t)\)</span>.</p>
<p>Por un lado, <span class="math display">\[\nabla \log(y_t) = \log(y_t) - \log(y_{t-1}) = \log\big(\frac{y_t}{y_{t-1}} \big)
  \approx \frac{y_t}{y_{t-1}} - 1 = \frac{y_t - y_{t-1}}{y_{t-1}} =TV y_t.\]</span></p>
<p>Por ejemplo, para una serie mensual <em>la diferencia regular del logaritmo (natural) es la Tasa de Variación Mensual de la serie</em> <span class="math inline">\((\nabla \log(y_t)=TVM y_t)\)</span>, que tiene una clara interpretación como variación porcentual.</p>
<p>Por otro lado, <span class="math display">\[\nabla_m \log(y_t) \approx \frac{y_t - y_{t-m}}{y_{t-m}} =TV_m y_t.\]</span></p>
<p>Es decir, para una serie mensual <em>la diferencia estacional del logaritmo es la Tasa de Variación Anual de la serie</em> <span class="math inline">\((\nabla_{12} \log(y_t)=TVA y_t)\)</span>.</p>
<p><br />
<br />
</p>
</div>
</div>
<div id="función-de-autocorrelación" class="section level1">
<h1><span class="header-section-number">4</span> Función de autocorrelación</h1>
<p>Si la serie es estacionaria y ergódica, el valor medio de la serie es constante y, por tanto, no informativo. <strong>Son las covarianzas los que caracterizan el proceso estocástico</strong>.</p>
<p>Recordemos que <span class="math inline">\(\gamma_k=Cov(y_t,y_{t-k})\)</span> es la autocovarianza de orden k. Por tanto <span class="math inline">\(\gamma_0\)</span> es la varianza de la serie <span class="math inline">\(y_t\)</span>. Sea <span class="math inline">\(\rho_k\)</span> la autocorrelación se orden <span class="math inline">\(k\)</span>. Se puede verificar que: <span class="math display">\[\rho_k = cor(y_t, y_{t-k}) =\frac{\gamma_k}{\gamma_0}.\]</span></p>
<ul>
<li><span class="math inline">\(\rho_1\)</span> mide la información que se transmite de un periodo al siguiente periodo.</li>
<li><span class="math inline">\(\rho_k\)</span> mide la información que se transmite k periodos hacia adelante.</li>
</ul>
<p>Las autocorrelaciones caracterizan el proceso estocástico, y <strong>la función de autocorrelación o correlograma (FAC, o ACF en inglés) es el gráfico de <span class="math inline">\(r_k\)</span> contra <span class="math inline">\(k\)</span></strong>, donde <span class="math inline">\(r_k\)</span> es la estimación de <span class="math inline">\(\rho_k\)</span> obtenida con las observaciones.</p>
<p>La figura 6 muestra la FAC para la serie Nacimientos y algunas de sus transformaciones. Observa el diferente uso del argumento <code>lag</code>: en la función <code>diff</code> indica el orden de la diferenciación, y en la función <code>ggAcf</code> indica el orden máximo de la autocorrelación. La primera columna muestra la FAC para Nacimientos y varias diferenciaciones, mientras que la segunda columna muestra la FAC para el logaritmo de los nacimientos y sus diferenciaciones. Se puede observar que:</p>
<ul>
<li>La FAC de una serie y de su transformación logarítmica son muy similares.</li>
<li>En los paneles de la primera y tercera fila las autocorrelaciones decrecen muy lentamente, indicando que la serie analizada no es estacionaria ni ergódica.</li>
<li>En los paneles de la segunda fila las autocorrelaciones de orden estacional (12, 24,…) también decrecen lentamente, indicando que la serie analizada no es ergódica.</li>
<li>Solo la doble diferenciación regular y estacional de la serie (original o su logaritmo) muestran un rápido descenso en los coeficiente de autocorrelación (paneles de la última fila), indicando que la serie así transformada es estacionaria en media y ergódica.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">ggAcf</span>(nacimientos, <span class="dt">lag =</span> <span class="dv">48</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">ggAcf</span>(<span class="kw">log</span>(nacimientos), <span class="dt">lag =</span> <span class="dv">48</span>)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(nacimientos), <span class="dt">lag =</span> <span class="dv">48</span>)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(<span class="kw">log</span>(nacimientos)), <span class="dt">lag =</span> <span class="dv">48</span>)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(nacimientos, <span class="dt">lag =</span> <span class="dv">12</span>),<span class="dt">lag =</span> <span class="dv">48</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(<span class="kw">log</span>(nacimientos), <span class="dt">lag =</span> <span class="dv">12</span>), <span class="dt">lag =</span> <span class="dv">48</span>)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(<span class="kw">diff</span>(nacimientos, <span class="dt">lag=</span><span class="dv">12</span>)), <span class="dt">lag =</span> <span class="dv">48</span>)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(<span class="kw">diff</span>(<span class="kw">log</span>(nacimientos), <span class="dt">lag=</span><span class="dv">12</span>)), <span class="dt">lag =</span> <span class="dv">48</span>)</a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-7-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>También podemos pedir <code>R</code> que nos sugiera los órdenes de diferenciación con las funciones <code>ndiffs</code> y <code>nsdiffs</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">ndiffs</span>(nacimientos)</a></code></pre></div>
<pre><code>[1] 1</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">nsdiffs</span>(nacimientos)</a></code></pre></div>
<pre><code>[1] 1</code></pre>
<p>Si queremos ver los valores numéricos de las autocorrelaciones debemos añadir a la función <code>ggAfc</code> el argumento <code>plot = FALSE</code>. Para la serie doblemente diferenciada vemos que las relaciones más elevadas se dan para un retardo (<span class="math inline">\(r_{1}=-0.396\)</span>) y para 12 retardos (<span class="math inline">\(r_{12}=-0.298\)</span>), el dato que más se parece a los nacimientos de un mes son los nacimientos del mes previo y los nacimientos del mismo mes del año previo.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(<span class="kw">diff</span>(nacimientos), <span class="dt">lag =</span> <span class="dv">12</span>), <span class="dt">lag=</span><span class="dv">12</span>, <span class="dt">plot =</span> <span class="ot">FALSE</span>)</a></code></pre></div>
<pre><code>
Autocorrelations of series &#39;diff(diff(nacimientos), lag = 12)&#39;, by lag

     0      1      2      3      4      5      6      7      8      9     10 
 1.000 -0.396 -0.006  0.031 -0.117 -0.045  0.072 -0.038  0.050  0.097 -0.067 
    11     12 
 0.105 -0.298 </code></pre>
<p>Las bandas azules de la FAC muestran el intervalo de confianza al 95% (IC95). Si <span class="math inline">\(\rho_k = 0\)</span>, la distribución del estimador <span class="math inline">\(r_k\)</span> se distribuye aproximadamente como una normal de media <span class="math inline">\(-1/T\)</span> y varianza <span class="math inline">\(1/T\)</span>. Las líneas punteadas de la FAC están dibujadas en las posiciones <span class="math inline">\(\frac{-1}{T} \pm \frac{1.96}{\sqrt{T}}\)</span>.</p>
<ul>
<li><p>Si un <span class="math inline">\(r_k\)</span> cae fuera del IC95 hay evidencia para rechazar la hipótesis nula de que <span class="math inline">\(\rho_k = 0\)</span> a un nivel del 5%. Recordemos que incluso si todos los <span class="math inline">\(\rho_k\)</span> son cero, cabe esperar que un 5% de sus estimaciones <span class="math inline">\(r_k\)</span> caigan fuera del IC95.</p></li>
<li><p>Los <span class="math inline">\(\rho_k\)</span> no son independientes. Si uno cae fuera del IC95, es más probable que los valores vecinos caigan también fuera.</p></li>
</ul>
<p><br />
<br />
</p>
</div>
<div id="procesos-arima" class="section level1">
<h1><span class="header-section-number">5</span> Procesos ARIMA</h1>
<p>ARIMA surge de combinar las siglas de tres procesos diferentes: <strong>AR</strong> de AutoRegresive, <strong>I</strong> de Integrated y <strong>MA</strong> de Moving Average. Veamos cada uno de estos tres conceptos por separado y luego su combinación.</p>
<p>A lo largo de lo que resta del tema asumiremos que:</p>
<ul>
<li><p><span class="math inline">\(\{y_t\}_{t=1}^T\)</span> es una realización de un proceso estocástico desconocido.</p></li>
<li><p>El proceso estocástico es <strong>estacionario en sentido amplio</strong>: <span class="math display">\[E[y_t]  = \mu &lt; \infty \;\;\; \forall t,\]</span> <span class="math display">\[Cov[y_t, y_{t-k}]  = \gamma_k  \;\;\; \forall k.\]</span></p></li>
<li><p>El proceso estocástico es <strong>ergódico</strong>, o su condición suficiente: <span class="math display">\[\lim_{k \rightarrow \infty} \gamma_k  = 0.\]</span></p></li>
</ul>
<p><br />
</p>
<div id="procesos-autorregresivos-arp" class="section level2">
<h2><span class="header-section-number">5.1</span> Procesos autorregresivos AR(p)</h2>
<div id="definición" class="section level3 unnumbered">
<h3>Definición</h3>
<p>El modelo general <strong>autorregresivo de orden p</strong>, <span class="math inline">\(y_t \sim AR(p)\)</span> viene definido por <span class="math display">\[y_t=c + \phi_1 y_{t-1} + \phi_2 y_{t-2} + ... + \phi_p y_{t-p} + \varepsilon_t,\]</span> que usando el operador retardo queda <span class="math display">\[(1 - \phi_1 L - \phi_2 L^2 - ... - \phi_p L^p)y_t = c + \varepsilon_t\]</span></p>
<p>En este y en cualquier proceso ARIMA, al polinomio en <span class="math inline">\(L\)</span> que acompaña a <span class="math inline">\(y_t\)</span> se le denomina <strong>polinomio autoregresivo</strong>.</p>
<p>Se suele asumir que el error del modelo <span class="math inline">\(\varepsilon_t\)</span> verifica las hipótesis estándar de media cero, incorrelación, homocedasticidad e idéntica distribución: <span class="math inline">\(\varepsilon_t \sim iid(0, \sigma^2)\)</span>. En este curso no vamos a prestar atención a este conjunto de hipótesis porque no jugarán ningún papel en la elección del modelo óptimo –aquel con mejores predicciones.</p>
</div>
<div id="ejemplos" class="section level3 unnumbered">
<h3>Ejemplos</h3>
<ul>
<li><span class="math inline">\(y_t \sim AR(1): \;\;y_t = c + \phi_1 y_{t-1} + \varepsilon_t\)</span> o <span class="math inline">\((1 - \phi_1 L)y_t = c + \varepsilon_t\)</span></li>
<li><span class="math inline">\(y_t \sim AR(2): \;\;y_t = c + \phi_1 y_{t-1} + \phi_2 y_{t-2} + \varepsilon_t\)</span> o <span class="math inline">\((1 - \phi_1 L - \phi_2 L^2)y_t = c + \varepsilon_t\)</span></li>
</ul>
<p><br />
</p>
</div>
</div>
<div id="procesos-en-medias-móviles-maq" class="section level2">
<h2><span class="header-section-number">5.2</span> Procesos en medias móviles MA(q)</h2>
<div id="definición-1" class="section level3 unnumbered">
<h3>Definición</h3>
<p>El modelo general <strong>en medias móviles de orden q</strong>, <span class="math inline">\(y_t \sim MA(q)\)</span> viene definido por <span class="math display">\[y_t=c + \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + ... + \theta_q \varepsilon_{t-q},\]</span> que usando el operador retardo queda <span class="math display">\[y_t = c + (1 + \theta_1 L + \theta_2 L^2 + ... + \theta_q L^q) \varepsilon_t\]</span></p>
</div>
<div id="ejemplos-1" class="section level3 unnumbered">
<h3>Ejemplos</h3>
<ul>
<li><span class="math inline">\(y_t \sim MA(1): \;\;y_t = c + \varepsilon_t + \theta_1 \varepsilon_{t-1}\)</span> o <span class="math inline">\(y_t = c + (1 + \theta_1 L)\varepsilon_t\)</span></li>
<li><span class="math inline">\(y_t \sim MA(2): \;\;y_t=c + \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2}\)</span> o <span class="math inline">\(y_t = c + (1 + \theta_1 L + \theta_2 L^2)\varepsilon_t\)</span></li>
</ul>
<p><br />
</p>
</div>
</div>
<div id="procesos-armapq" class="section level2">
<h2><span class="header-section-number">5.3</span> Procesos ARMA(p,q)</h2>
<div id="definición-2" class="section level3 unnumbered">
<h3>Definición</h3>
<p>El modelo general <span class="math inline">\(y_t \sim ARMA(p,q)\)</span> viene dado por <span class="math display">\[y_t = c + \phi_1 y_{t-1} + \phi_2 y_{t-2} + ... + \phi_p y_{t-p}  + 
        \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + ... +
        \theta_q \varepsilon_{t-q}+ \varepsilon_t,\]</span> que usando el operador retardo queda <span class="math display">\[(1 - \phi_1 L - ... - \phi_p L^p)y_t = c + (1 + \theta_1 L + ... + \theta_q L^q) \varepsilon_t.\]</span></p>
</div>
<div id="ejemplos-2" class="section level3 unnumbered">
<h3>Ejemplos</h3>
<ul>
<li><span class="math inline">\(y_t \sim ARMA(1, 1): \;\;y_t = c + \phi_1 y_{t-1} + \theta_1 \varepsilon_{t-1} + \varepsilon_{t}\)</span> o <span class="math inline">\((1 - \phi_1 L)y_t = c + (1 + \theta_1 L)\varepsilon_t\)</span>.</li>
<li><span class="math inline">\(y_t \sim ARMA(0, 0): \;\;y_t = c + \varepsilon_{t}\)</span>. Si <span class="math inline">\(c = 0\)</span>, a este proceso se le denommina <strong>ruido blanco</strong>.</li>
</ul>
<p><br />
</p>
</div>
</div>
<div id="proceso-arimapdq" class="section level2">
<h2><span class="header-section-number">5.4</span> Proceso ARIMA(p,d,q)</h2>
<p><strong>Si la serie <span class="math inline">\(y_t\)</span> no es estacionaria pero tras diferenciarla <span class="math inline">\(d\)</span> veces se hace estacionaria, diremos que la serie es integrada de orden <span class="math inline">\(d\)</span></strong>: <span class="math inline">\(y_t \sim I(d)\)</span>. Por tanto,</p>
<ul>
<li>una serie estacionaria se indicará como <span class="math inline">\(y_t \sim I(0)\)</span></li>
<li><span class="math inline">\(y_t \sim I(d)\)</span> es equivalente a <span class="math inline">\(\nabla^d y_t = (1 - L)^d y_t \sim I(0)\)</span></li>
</ul>
<p>Una serie <span class="math inline">\(y_t\)</span> sigue un proceso <strong><span class="math inline">\(ARIMA(p,d,q)\)</span></strong> si:</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(y_t \sim I(d)\)</span> (hay que diferenciarla <span class="math inline">\(d\)</span> veces para hacerla estacionaria), y</li>
<li><span class="math inline">\(\nabla^d y_t \sim ARMA(p,q)\)</span>.</li>
</ol>
<p>Entonces, podemos escribir: <span class="math display">\[y_t \sim  ARIMA(p,d,q): \;\;\; (1 - \phi_1 L - \ldots - \phi_p L^p)(1- L)^d y_t = c + (1 + \theta_1 L + ... + \theta_q L^q) \varepsilon_t.\]</span></p>
<div id="ejemplos-3" class="section level3 unnumbered">
<h3>Ejemplos</h3>
<ul>
<li><span class="math inline">\(y_t \sim ARIMA(1, 1, 1): \;\;(1 - \phi_1 L)(1- L) y_t = c + (1 + \theta_1 L) \varepsilon_t\)</span> o <span class="math inline">\(y_t = c + y_{t-1} + \phi_1(y_{t-1} - y_{t-2}) + \theta_1 \varepsilon_{t-1} + \varepsilon_t\)</span>.</li>
<li><span class="math inline">\(y_t \sim ARIMA(0, 1, 0): \;\;(1- L) y_t = c + \varepsilon_t\)</span> o <span class="math inline">\(y_t = c + y_{t-1} + \varepsilon_t\)</span>. Si <span class="math inline">\(c=0\)</span>, tenemos un <strong>paseo aletorio</strong>; si <span class="math inline">\(c \neq 0\)</span>, tenemos un <strong>paseo aleatorio con deriva</strong>.</li>
</ul>
<p><br />
<br />
</p>
</div>
</div>
</div>
<div id="aproximación-de-box-jenkins" class="section level1">
<h1><span class="header-section-number">6</span> Aproximación de Box-Jenkins</h1>
<p>La siguiente figura muestra el flujo de procesos asociado a la modelización por modelos ARIMA, con cuatro grandes áreas:</p>
<ul>
<li><p><strong>Identificación</strong>, que requiere primero transformar la serie para que sea estacionaria y ergódica, para después identificar los valores de p y q.</p>
<p>La FAC y la función de autocorrelación parcial (que no hemos visto) teóricas son diferentes en cada tipo de proceso. Idealmente, su estimación a partir de la serie temporal podría servir de ayuda en la identificación del proceso estocástico. En la práctica, la funciones estimadas son tan diferentes de las teóricas que resultan de muy poca ayuda.</p>
<p>Nosotros haremos uso de algunas funciones de <em>auto</em> identificación que nos ayudaran en este punto.</p></li>
<li><p><strong>Estimación</strong> de los parámetros del modelo, incluidas las variables de intervención y obtención del error. Dado un proceso, el método usual de estimación de sus parámetros es por máxima verosimilitud.</p></li>
<li><p><strong>Validación</strong> de las hipótesis sobre el modelo.</p>
<p>En un curso tradicional de modelos Arima supondría validar la hipótesis sobre el residuo, contrastes de significatividad de los parámetros estimados y comprobación de que no hay más intervención.</p>
<p>En nuestro caso, que hemos reducido las hipótesis a su mínima expresión, simplemente analizaremos que no es necesaria más intervención y veremos la pertinencia de los parámetros del modelo (bien contrastando su significatividad o bien por alguna regla más sencilla).</p>
<p>Si la validación no se pasa, puede ser necesario volver al proceso inicial y realizar una nueva identificación del modelo.</p></li>
<li><p><strong>Predicción</strong> e interpretación del modelo válido. Si las predicciones se alejan de los valores reales más de lo esperado o presentan sesgo, puede ser necesario identificar y estimar un nuevo modelo.</p></li>
</ul>
<p><img src="imagenes/BoxJenkins.png" alt="Aproximación Box-Jenkins" /></p>
<p><br />
<br />
</p>
<div id="identificación-automática" class="section level3 unnumbered">
<h3>Identificación automática</h3>
<p>El paquete <code>forecast</code> dispone de la función <code>auto.arima()</code> que localiza el mejor modelo basándose en el AIC corregido para pequeñas muestras (<code>AICc</code>). No hay que fiarse ciegamente de los resultados de esta función, pero ayuda en la identificación. Básicamente el algoritmo seguido es el siguiente:</p>
<ol style="list-style-type: decimal">
<li>Determina el orden de diferenciación regular <span class="math inline">\(0 \leq d \leq 2\)</span> usando la función <code>ndiffs</code>.</li>
<li>Tras diferenciar la serie:
<ul>
<li>se estiman una serie de modelos básicos predeterminados.</li>
<li>se usa el criterio AICc para seleccionar el mejor de estos modelos.</li>
<li>a partir del modelo seleccionado, se hacen pequeñas variaciones modificando en una unidad <em>p</em> y <em>q</em> y añadiendo/quitando la constante y se vuelve a seleccionar el mejor de los nuevos modelos.</li>
</ul></li>
<li>Se repite el paso 2 hasta que no se puede mejorar el AICc.</li>
</ol>
<p>Cuando usemos esta función, debemos tener cuenta que:</p>
<ul>
<li>La función <code>auto.arima</code> no permite contante si la suma de las diferenciaciones es 2 o superior.</li>
<li>Si se desea hacer una búsqueda exhaustiva entre todos los posibles modelos se debe usar el argumento <code>stepwise = FALSE</code>.</li>
<li>Si se desea que el cálculo de AICc sea exacto (por defecto para ganar tiempo calcula una aproximación), se debe usar el argumento <code>approximation = FALSE</code>.</li>
<li>Si se desea ver para todos los modelos analizados el valor de AICc, se debe incluir el argumento <code>trace = TRUE</code>.</li>
</ul>
<p>La función <code>auto.arima</code> tiende a sobre-parametrizar los modelos y es muy recomendable <em>ayudarla</em> indicando las diferenciaciones, los posibles valores extremos…</p>
<p><br />
<br />
</p>
</div>
</div>
<div id="ejemplos-4" class="section level1">
<h1><span class="header-section-number">7</span> Ejemplos</h1>
<p><br />
</p>
<div id="títulos-de-libros-y-panfletos" class="section level2">
<h2><span class="header-section-number">7.1</span> Títulos de libros y panfletos</h2>
<p>Vamos a aplicar la metodología de Box-Jenkins a la serie Libros (número de títulos publicados anualmente en España desde 1993 hasta 2018).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" data-line-number="1">libros &lt;-<span class="st"> </span><span class="kw">read.csv2</span>(<span class="st">&quot;./series/libros.csv&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">libros &lt;-<span class="st"> </span><span class="kw">ts</span>(libros[, <span class="dv">2</span>], <span class="dt">start =</span> <span class="dv">1993</span>, <span class="dt">frequency =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">autoplot</span>(libros,</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">         <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, </a>
<a class="sourceLine" id="cb8-6" data-line-number="6">         <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, </a>
<a class="sourceLine" id="cb8-7" data-line-number="7">         <span class="dt">main =</span> <span class="st">&quot;Figura 7. Títulos publicados&quot;</span>)</a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-10-1.png" width="80%" style="display: block; margin: auto;" /></p>
<div id="transformación-de-la-serie" class="section level3 unnumbered">
<h3>Transformación de la serie</h3>
<p>El primer paso es transformar la serie original para que sea estacionaria. La figura 8 muestra la gráfica temporal y la FAC para la serie original y su primera diferencia.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">autoplot</span>(libros, <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Libros&quot;</span>)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">autoplot</span>(<span class="kw">diff</span>(libros), <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Diferencia libros&quot;</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">ggAcf</span>(libros, <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;FAC&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(libros), <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;FAC&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-12-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Además,</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">ndiffs</span>(libros)</a></code></pre></div>
<pre><code>[1] 1</code></pre>
<p>Podemos cocluir que la primera diferencia de la serie Libros es estacionaria y ergódica. Es decir, <span class="math inline">\(d=1\)</span> o <span class="math inline">\(libros \sim I(1)\)</span>.</p>
</div>
<div id="identificación" class="section level3 unnumbered">
<h3>Identificación</h3>
<p>Tras diferenciar la serie, vamos a identificar los valores de <span class="math inline">\(p\)</span> y <span class="math inline">\(q\)</span>. Este es el proceso más difícil y para simplificar las cosas vamos a ayudarnos de la función <code>auto.arima</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">auto.arima</span>(libros, <span class="dt">trace =</span> <span class="ot">TRUE</span>)</a></code></pre></div>
<pre><code>
 ARIMA(2,1,2) with drift         : Inf
 ARIMA(0,1,0) with drift         : 510.0603
 ARIMA(1,1,0) with drift         : 512.623
 ARIMA(0,1,1) with drift         : 512.6173
 ARIMA(0,1,0)                    : 508.2017
 ARIMA(1,1,1) with drift         : Inf

 Best model: ARIMA(0,1,0)                    </code></pre>
<pre><code>Series: libros 
ARIMA(0,1,0) 

sigma^2 estimated as 36151817:  log likelihood=-253.01
AIC=508.03   AICc=508.2   BIC=509.25</code></pre>
<p>Observa como la identificación automática da como mejor modelo <span class="math inline">\(libros_t \sim ARIMA(0,1,0)\)</span> sin deriva, por tanto, ruido blanco, <span class="math inline">\(p=q=0\)</span>: <span class="math display">\[libros_t = libros_{t-1} + \varepsilon_t\]</span></p>
</div>
<div id="estimación" class="section level3 unnumbered">
<h3>Estimación</h3>
<p>Aunque existe la función <code>arima</code> de <code>stats</code>, vamos a usar la función <code>Arima</code> de la librería <code>forecast</code> para estimar el modelo identificado por ser más versátil. El argumento <code>order</code> indica los valores de (p, d , q) como un vector y el argumento lógico <code>include.constant</code> indica si se desea incluir la constante <span class="math inline">\(c\)</span> en el modelo. (Mira en la ayuda de la función <code>Arima</code> la diferencia entre los argumentos <code>include.mean</code>, <code>include.drift</code> e <code>include.constant</code>).</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1">arima010 &lt;-<span class="st"> </span><span class="kw">Arima</span>(libros, </a>
<a class="sourceLine" id="cb15-2" data-line-number="2">                 <span class="dt">order=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>), </a>
<a class="sourceLine" id="cb15-3" data-line-number="3">                 <span class="dt">include.constant =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">arima010</a></code></pre></div>
<pre><code>Series: libros 
ARIMA(0,1,0) 

sigma^2 estimated as 36151817:  log likelihood=-253.01
AIC=508.03   AICc=508.2   BIC=509.25</code></pre>
<p>Nuestro modelo estimado es: <span class="math inline">\(\widehat{libros}_t = libros_{t-1}\)</span>. La mejor predicción para un año, es la observación del año anterior, ¡el método ingenuo I!</p>
</div>
<div id="intervención" class="section level3 unnumbered">
<h3>Intervención</h3>
<p>Se analiza si para algún año se observa un error atípico (por ejemplo 3 veces superior al error estándar). La figura 9 muestra que en este caso en dos periodos, años 2008 y 2013, el residuo sobrepasa los dos errores estándar pero queda lejos de los tres errores estándar así que asumiremos que no hay valores atípicos.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">error &lt;-<span class="st"> </span><span class="kw">residuals</span>(arima010)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">sderror &lt;-<span class="st"> </span><span class="kw">sd</span>(error)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw">autoplot</span>(error, <span class="dt">series=</span><span class="st">&quot;Error&quot;</span>,</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">         <span class="dt">colour =</span> <span class="st">&quot;black&quot;</span>,</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">         <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>,</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">         <span class="dt">ylab =</span> <span class="st">&quot;Error&quot;</span>,</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">         <span class="dt">main =</span> <span class="st">&quot;Figura 9. Error + Intervención&quot;) +</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9"><span class="st">  geom_hline(yintercept = c(-3, -2, 2, 3)*sderror, </span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10"><span class="st">             colour = c(&quot;</span>red<span class="st">&quot;, &quot;</span>green<span class="st">&quot;, &quot;</span>green<span class="st">&quot;, &quot;</span>red<span class="st">&quot;), </span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11"><span class="st">             lty = 2) + </span></a>
<a class="sourceLine" id="cb17-12" data-line-number="12"><span class="st">  geom_point() +</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13"><span class="st">  scale_x_continuous(breaks= seq(1993, 2019, 2)) </span></a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-16-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
<div id="medidas-de-error" class="section level3 unnumbered">
<h3>Medidas de error</h3>
<p>El error medio es 5896 títulos (RMSE) y el error porcentual medio (MAPE) es 7.02%.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">accuracy</span>(arima010)</a></code></pre></div>
<pre><code>                 ME    RMSE     MAE  MPE MAPE MASE  ACF1
Training set 825.49 5895.88 4450.03 1.23 7.02 0.96 -0.04</code></pre>
</div>
<div id="predicción" class="section level3 unnumbered">
<h3>Predicción</h3>
<p>Una vez validado el modelo podemos pasar a realizar <strong>predicciones</strong>, en este caso a 5 años vista.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">parima010 &lt;-<span class="st"> </span><span class="kw">forecast</span>(arima010, <span class="dt">h =</span> <span class="dv">5</span>, <span class="dt">level =</span> <span class="dv">95</span>)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">parima010</a></code></pre></div>
<pre><code>     Point Forecast    Lo 95    Hi 95
2019          62180 50395.45 73964.55
2020          62180 45514.12 78845.88
2021          62180 41768.55 82591.45
2022          62180 38610.89 85749.11
2023          62180 35828.94 88531.06</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">autoplot</span>(parima010, </a>
<a class="sourceLine" id="cb22-2" data-line-number="2">         <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, </a>
<a class="sourceLine" id="cb22-3" data-line-number="3">         <span class="dt">ylab =</span> <span class="st">&quot;Títulos&quot;</span>,</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">         <span class="dt">main =</span> <span class="st">&quot;Figure 10. Libros (1993-2018) y predicción (2019-2023)&quot;</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="st">  </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks=</span> <span class="kw">seq</span>(<span class="dv">1993</span>, <span class="dv">2023</span>, <span class="dv">2</span>)) </a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-20-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>La figura 10 muestra la serie, la previsión y el intervalo de confianza al 95%. La predicción es constante e igual al último dato. En las series diferenciadas el intervalo de confianza de las predicciones crece muy rápidamente porque los errores se van acumulando sin ningún tipo de amortiguamiento.</p>
<p><br />
</p>
</div>
</div>
<div id="aforo-de-vehículos" class="section level2">
<h2><span class="header-section-number">7.2</span> Aforo de vehículos</h2>
<p>Vamos a aplicar de nuevo la metodología de Box-Jenkins a la serie <strong>aforo de vehículos</strong> por Oropesa, carretera N-340, km. 996,48 (fuente Ministerio de Fomento). La serie es anual de 1960 a 2018 (59 datos).</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb23-1" data-line-number="1">aforo &lt;-<span class="st"> </span><span class="kw">read.csv2</span>(<span class="st">&quot;./series/aforo_oropesa.csv&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">aforo &lt;-<span class="st"> </span><span class="kw">ts</span>(aforo, <span class="dt">start =</span> <span class="dv">1960</span>, <span class="dt">freq =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="kw">autoplot</span>(aforo, </a>
<a class="sourceLine" id="cb23-5" data-line-number="5">         <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, </a>
<a class="sourceLine" id="cb23-6" data-line-number="6">         <span class="dt">ylab =</span> <span class="st">&quot;Vehículos (000)&quot;</span>,</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">         <span class="dt">main =</span> <span class="st">&quot;Figura 11. Aforo de vehículos en N-340, Oropesa&quot;</span>)</a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-21-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>En este ejemplo vamos a trabajar con el logaritmo de la serie para poder ver algunos detalles relacionados con la interpretación del modelo y la predicción. Además, incluiremos, por primera vez, intervención y veremos como <strong>la presencia de valores atípicos puede distorsionar el proceso de identificación</strong>. Por ello, es conveniente realizar en paralelo ambas actividades, identificar el proceso y detectar valores atípicos.</p>
<div id="transformación-de-la-serie-1" class="section level3 unnumbered">
<h3>Transformación de la serie</h3>
<p>La figura 12 muestra que la serie Aforo (log) no es estacionaria. Así, el primer paso es transformar la serie original para que lo sea. La figura 12 no deja claro si la primera diferencia es suficiente para alcanzar la estacionariedad (gráficos de la segunda columna). Sin embargo, tras diferenciar dos veces la serie es claramente estacionaria. Por tanto se opta por considerar <span class="math inline">\(d=2\)</span> o <span class="math inline">\(log(aforo_t) \sim I(2)\)</span>. La función <code>ndiffs</code> también aconseja la doble diferenciación.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">autoplot</span>(<span class="kw">log</span>(aforo), </a>
<a class="sourceLine" id="cb24-2" data-line-number="2">         <span class="dt">xlab =</span> <span class="st">&quot;log(Aforo)&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">autoplot</span>(<span class="kw">diff</span>(<span class="kw">log</span>(aforo)), </a>
<a class="sourceLine" id="cb24-4" data-line-number="4">         <span class="dt">xlab =</span> <span class="st">&quot;Una diferencia de log(Aforo)&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">autoplot</span>(<span class="kw">diff</span>(<span class="kw">log</span>(aforo), <span class="dt">differences =</span> <span class="dv">2</span>), </a>
<a class="sourceLine" id="cb24-6" data-line-number="6">         <span class="dt">xlab =</span> <span class="st">&quot;Dos diferencias de log(Aforo)&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb24-7" data-line-number="7"><span class="kw">ggAcf</span>(<span class="kw">log</span>(aforo), <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;FAC&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(<span class="kw">log</span>(aforo)), <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;FAC&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(<span class="kw">log</span>(aforo), <span class="dt">differences =</span> <span class="dv">2</span>), <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;FAC&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-23-1.png" width="80%" style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">ndiffs</span>(<span class="kw">log</span>(aforo))</a></code></pre></div>
<pre><code>[1] 2</code></pre>
</div>
<div id="identificación-1" class="section level3 unnumbered">
<h3>Identificación</h3>
<p>Veamos a identificar los valores de <span class="math inline">\(p\)</span> y <span class="math inline">\(q\)</span> a partir de <code>auto.arima</code>. La función sugiere un proceso MA(2). Parece que los dos coeficientes estimados son significativos –la estimación es mayor que dos veces su error estándar (standard error, s.e).</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">auto.arima</span>(aforo, </a>
<a class="sourceLine" id="cb27-2" data-line-number="2">           <span class="dt">lambda =</span> <span class="dv">0</span>)</a></code></pre></div>
<pre><code>Series: aforo 
ARIMA(0,2,2) 
Box Cox transformation: lambda= 0 

Coefficients:
          ma1     ma2
      -0.8545  0.4642
s.e.   0.1331  0.1666

sigma^2 estimated as 0.007095:  log likelihood=60.72
AIC=-115.44   AICc=-114.99   BIC=-109.32</code></pre>
<p>Vamos a ver la gráfica de los residuos del modelo MA(2), vamos a identificar los valores extremos (intervención) y vamos a solicitar una vez más la auto-identificación pero incluyendo las variables ficticias asociadas a cada valor extremo.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1">arima022 &lt;-<span class="st"> </span><span class="kw">Arima</span>(aforo, </a>
<a class="sourceLine" id="cb29-2" data-line-number="2">                  <span class="dt">order =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">2</span>),</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">                  <span class="dt">lambda =</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb29-4" data-line-number="4"></a>
<a class="sourceLine" id="cb29-5" data-line-number="5">error &lt;-<span class="st"> </span><span class="kw">residuals</span>(arima022)</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">sderror &lt;-<span class="st"> </span><span class="kw">sd</span>(error)</a>
<a class="sourceLine" id="cb29-7" data-line-number="7"></a>
<a class="sourceLine" id="cb29-8" data-line-number="8"><span class="kw">autoplot</span>(error, <span class="dt">series=</span><span class="st">&quot;Error&quot;</span>,</a>
<a class="sourceLine" id="cb29-9" data-line-number="9">         <span class="dt">colour =</span> <span class="st">&quot;black&quot;</span>,</a>
<a class="sourceLine" id="cb29-10" data-line-number="10">         <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>,</a>
<a class="sourceLine" id="cb29-11" data-line-number="11">         <span class="dt">ylab =</span> <span class="st">&quot;Error&quot;</span>,</a>
<a class="sourceLine" id="cb29-12" data-line-number="12">         <span class="dt">main =</span> <span class="st">&quot;Figura 13. Error + Intervención&quot;) +</span></a>
<a class="sourceLine" id="cb29-13" data-line-number="13"><span class="st">  geom_hline(yintercept = c(-3, -2, 2, 3)*sderror, </span></a>
<a class="sourceLine" id="cb29-14" data-line-number="14"><span class="st">             colour = c(&quot;</span>red<span class="st">&quot;, &quot;</span>green<span class="st">&quot;, &quot;</span>green<span class="st">&quot;, &quot;</span>red<span class="st">&quot;), </span></a>
<a class="sourceLine" id="cb29-15" data-line-number="15"><span class="st">             lty = 2) + </span></a>
<a class="sourceLine" id="cb29-16" data-line-number="16"><span class="st">  geom_point() +</span></a>
<a class="sourceLine" id="cb29-17" data-line-number="17"><span class="st">  scale_x_continuous(breaks= seq(1960, 2014, 4)) </span></a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-26-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Se identifican dos posibles valores extremos en los años 1979 y 1981. Además, vamos a incluir otras dos intervenciones para los años 1984 y 2011 porque si no serían necesarias más adelante. Entonces, creamos una variable ficticia asociada a cada año d1979, d1981, d1984 y d2011, y las incluimos en la auto-identificación.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" data-line-number="1">d1979 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">*</span>(<span class="kw">time</span>(error) <span class="op">==</span><span class="st"> </span><span class="dv">1979</span>)</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">d1981 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">*</span>(<span class="kw">time</span>(error) <span class="op">==</span><span class="st"> </span><span class="dv">1981</span>)</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">d1984 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">*</span>(<span class="kw">time</span>(error) <span class="op">==</span><span class="st"> </span><span class="dv">1984</span>)</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">d2011 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">*</span>(<span class="kw">time</span>(error) <span class="op">==</span><span class="st"> </span><span class="dv">2011</span>)</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="kw">auto.arima</span>(aforo, </a>
<a class="sourceLine" id="cb30-7" data-line-number="7">           <span class="dt">lambda =</span> <span class="dv">0</span>, </a>
<a class="sourceLine" id="cb30-8" data-line-number="8">           <span class="dt">xreg =</span> <span class="kw">cbind</span>(d1979, d1981, d1984, d2011))</a></code></pre></div>
<pre><code>Series: aforo 
Regression with ARIMA(1,2,0) errors 
Box Cox transformation: lambda= 0 

Coefficients:
          ar1    d1979   d1981   d1984    d2011
      -0.6561  -0.1522  0.0841  0.0773  -0.0881
s.e.   0.1013   0.0409  0.0413  0.0384   0.0374

sigma^2 estimated as 0.005104:  log likelihood=71.88
AIC=-131.76   AICc=-130.08   BIC=-119.51</code></pre>
<p>Observa como la inclusión de intervención modifica la auto-identificación, que ahora es un proceso ARIMA(1,2,0). Asumimos que <span class="math inline">\(log(aforo_t) \sim ARIMA(1,2,0)\)</span> con intervención.</p>
</div>
<div id="estimación-1" class="section level3 unnumbered">
<h3>Estimación</h3>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1">arima120 &lt;-<span class="st"> </span><span class="kw">Arima</span>(aforo, </a>
<a class="sourceLine" id="cb32-2" data-line-number="2">                  <span class="dt">order =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">0</span>), </a>
<a class="sourceLine" id="cb32-3" data-line-number="3">                  <span class="dt">lambda =</span> <span class="dv">0</span>,  </a>
<a class="sourceLine" id="cb32-4" data-line-number="4">                  <span class="dt">xreg =</span> <span class="kw">cbind</span>(d1979, d1981, d1984, d2011))</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">arima120</a></code></pre></div>
<pre><code>Series: aforo 
Regression with ARIMA(1,2,0) errors 
Box Cox transformation: lambda= 0 

Coefficients:
          ar1    d1979   d1981   d1984    d2011
      -0.6561  -0.1522  0.0841  0.0773  -0.0881
s.e.   0.1013   0.0409  0.0413  0.0384   0.0374

sigma^2 estimated as 0.005104:  log likelihood=71.88
AIC=-131.76   AICc=-130.08   BIC=-119.51</code></pre>
<p>La identificación de errores atípicos –para la posterior inclusión de sus variables de intervención asociadas– ha sido un tanto arbitraria: ¿es atípico el error que supera las 2 desviaciones típicas, las dos y media, las tres desviaciones típicas?</p>
<p>A fin de poner un poco de <em>objetividad</em> en la decisión, podemos ver si sus coeficientes son significativos y dejar solo aquellas variables de intervención que lo sean. Aunque si la serie es suficientemente larga, también podríamos saltarnos este paso y dejar las variables de intervención que mejoren las predicciones extra-muestrales del modelo o las que recojan efectos con una gran evidencia.</p>
<p>La prueba de Wald permite contrastar si un subconjunto de coeficientes es significativo (se precisa la librería <code>aod</code>). Esta función requiere de tres argumentos: el vector de coeficientes (<code>b</code>), su matriz de covarianzas (<code>Sigma</code>) y la posición de los coeficientes cuya significatividad conjunta deseamos contrastar (<code>Terms</code>). Los dos primeros argumentos los podemos obtener del objeto <code>arima120</code> con las funciones <code>coef</code> y <code>vcov</code>.</p>
<p>Por ejemplo, para ver la significatividad de la primera variable de intervención (segundo coeficiente del modelo), tendríamos</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">wald.test</span>(<span class="dt">b =</span> <span class="kw">coef</span>(arima120), </a>
<a class="sourceLine" id="cb34-2" data-line-number="2">                  <span class="dt">Sigma =</span> <span class="kw">vcov</span>(arima120), </a>
<a class="sourceLine" id="cb34-3" data-line-number="3">                  <span class="dt">Terms =</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>Wald test:
----------

Chi-squared test:
X2 = 13.9, df = 1, P(&gt; X2) = 0.0002</code></pre>
<p>Con algo más de código se puede comprobar que todas las variables son significativas.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1">ancho &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="kw">nchar</span>(<span class="kw">names</span>(<span class="kw">coef</span>(arima120)))) <span class="op">+</span><span class="st"> </span><span class="dv">2</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(<span class="kw">coef</span>(arima120))) {</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">  wt &lt;-<span class="st"> </span><span class="kw">wald.test</span>(<span class="dt">b =</span> <span class="kw">coef</span>(arima120), </a>
<a class="sourceLine" id="cb36-4" data-line-number="4">                  <span class="dt">Sigma =</span> <span class="kw">vcov</span>(arima120), </a>
<a class="sourceLine" id="cb36-5" data-line-number="5">                  <span class="dt">Terms =</span> i)</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">  <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">Coeficiente: &quot;</span>, <span class="kw">format</span>(<span class="kw">names</span>(<span class="kw">coef</span>(arima120))[i], <span class="dt">width =</span> ancho), <span class="st">&quot;valor de p: &quot;</span>, </a>
<a class="sourceLine" id="cb36-7" data-line-number="7">      <span class="kw">formatC</span>(wt<span class="op">$</span>result<span class="op">$</span>chi2[<span class="dv">3</span>], <span class="dt">digits =</span> <span class="dv">4</span>, <span class="dt">format =</span> <span class="st">&quot;f&quot;</span>))</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">}</a></code></pre></div>
<pre><code>
Coeficiente:  ar1     valor de p:  0.0000
Coeficiente:  d1979   valor de p:  0.0002
Coeficiente:  d1981   valor de p:  0.0415
Coeficiente:  d1984   valor de p:  0.0441
Coeficiente:  d2011   valor de p:  0.0185</code></pre>
</div>
<div id="intervención-1" class="section level3 unnumbered">
<h3>Intervención</h3>
<p>La figura 14 muestra que para ningún año se observa un error atípico. Si se incluye una intervención asociada al residuo más elevado en 1974, no resulta significativa.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1">error &lt;-<span class="st"> </span><span class="kw">residuals</span>(arima120)</a>
<a class="sourceLine" id="cb38-2" data-line-number="2">sderror &lt;-<span class="st"> </span><span class="kw">sd</span>(error)</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="kw">autoplot</span>(error, <span class="dt">series=</span><span class="st">&quot;Error&quot;</span>,</a>
<a class="sourceLine" id="cb38-5" data-line-number="5">         <span class="dt">colour =</span> <span class="st">&quot;black&quot;</span>,</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">         <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>,</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">         <span class="dt">ylab =</span> <span class="st">&quot;Error&quot;</span>,</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">         <span class="dt">main =</span> <span class="st">&quot;Figura 14. Error + Intervención&quot;) +</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="st">  geom_hline(yintercept = c(-3, -2, 2, 3)*sderror, </span></a>
<a class="sourceLine" id="cb38-10" data-line-number="10"><span class="st">             colour = c(&quot;</span>red<span class="st">&quot;, &quot;</span>green<span class="st">&quot;, &quot;</span>green<span class="st">&quot;, &quot;</span>red<span class="st">&quot;), </span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11"><span class="st">             lty = 2) + </span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12"><span class="st">  geom_point() +</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13"><span class="st">  scale_x_continuous(breaks= seq(1960, 2014, 4)) </span></a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-31-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
</p>
</div>
<div id="medidas-de-error-1" class="section level3 unnumbered">
<h3>Medidas de error</h3>
<p>El error medio es 748 miles de vehículos (RMSE) y el error porcentual medio (MAPE) es 5.24%.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">accuracy</span>(arima120)</a></code></pre></div>
<pre><code>                 ME   RMSE    MAE   MPE MAPE MASE ACF1
Training set -94.73 747.64 546.69 -0.69 5.24 0.79 0.08</code></pre>
</div>
<div id="interpretación-del-modelo" class="section level3 unnumbered">
<h3>Interpretación del modelo</h3>
<p>El <strong>modelo teórico</strong> es <span class="math inline">\(log(aforo_t) \sim ARIMA(1,2,0) + d1979 + d1981 + d9184 + d2011\)</span>: <span class="math display">\[(1 - \phi_1 L)(1 - L)^2 log(aforo_t) =  \varepsilon_t + \gamma_1 \cdot d1979 + \gamma_2 \cdot d1981 + \gamma_3 \cdot d1984 + \gamma_4 \cdot d2011.\]</span></p>
<p>Si sustituimos <span class="math inline">\((1 - L)^2 log(aforo_t)\)</span> por <span class="math inline">\((1 - L) TVAaforo_t\)</span>, donde <span class="math inline">\(TVAaforo\)</span> es la tasa de variación anual del aforo, y desarrollamos, queda: <span class="math display">\[TVAaforo_t = TVAaforo_{t-1} + \phi_1(TVAaforo_{t-1}-TVAaforo_{t-2}) +\]</span> <span class="math display">\[\gamma_1 \cdot d1979 + \gamma_2 \cdot d1981 + \gamma_3 \cdot d1984 + \gamma_4 \cdot d2011 + \varepsilon_t.\]</span></p>
<p>Finalmente. el <strong>modelo estimado</strong> es: <span class="math display">\[\widehat{TVAaforo}_t = TVAaforo_{t-1} -0.66(TVAaforo_{t-1}-TVAaforo_{t-2}) + \]</span> <span class="math display">\[ - 0.15 \cdot d1979 + 0.08 \cdot d1981 + 0.08 \cdot d1984 - 0.09 \cdot d2011.\]</span> Cada año la tasa de variación del aforo es el misma que la del año pasado menos un 66% del último incremento entre las tasas de variación.</p>
<p>Respecto de la intervención, en 1979 hubo un 15% menos de vehículos de lo esperado, en 1981 y 1984 en torno a un 8% más y en 2011 un 9% menos.</p>
</div>
<div id="predicción-1" class="section level3 unnumbered">
<h3>Predicción</h3>
<p>Como hemos incluido cuatro variables ficticias en el ajuste, de cara a predecir el aforo hemos de indicar cuales serán los valores futuros para estas variables. En este caso serán ceros puesto que son intervenciones que no responden a efectos calendario.</p>
<p>En <code>R</code> esto se hace incluyendo en el comando <code>forecast</code> el argumento <code>xreg = cbind(rep(0, 5), rep(0, 5), rep(0, 5), rep(0, 5))</code> que añade cinco ceros por cada variable de intervención porque la predicción va a ser a cinco años vista.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1">parima120 &lt;-<span class="st"> </span><span class="kw">forecast</span>(arima120, </a>
<a class="sourceLine" id="cb41-2" data-line-number="2">                      <span class="dt">h =</span> <span class="dv">5</span>, </a>
<a class="sourceLine" id="cb41-3" data-line-number="3">                      <span class="dt">level =</span> <span class="dv">95</span>,</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">                      <span class="dt">xreg =</span> <span class="kw">cbind</span>(<span class="dt">d1979=</span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">5</span>), <span class="dt">d1981=</span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">5</span>), </a>
<a class="sourceLine" id="cb41-5" data-line-number="5">                                   <span class="dt">d1984=</span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">5</span>), <span class="dt">d2011=</span><span class="kw">rep</span>(<span class="dv">0</span>, <span class="dv">5</span>)))</a>
<a class="sourceLine" id="cb41-6" data-line-number="6">parima120</a></code></pre></div>
<pre><code>     Point Forecast    Lo 95    Hi 95
2019       10010.48 8702.487 11515.06
2020       10134.58 8015.691 12813.59
2021       10310.85 7064.336 15049.35
2022       10456.36 6179.997 17691.84
2023       10626.42 5282.780 21375.26</code></pre>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">autoplot</span>(parima120, </a>
<a class="sourceLine" id="cb43-2" data-line-number="2">     <span class="dt">ylab =</span> <span class="st">&#39;Vehículos (000)&#39;</span>,</a>
<a class="sourceLine" id="cb43-3" data-line-number="3">     <span class="dt">main =</span> <span class="st">&#39;Figura 15. Aforo (1960-2018) y predicción (2019-2023)&#39;</span>) <span class="op">+</span></a>
<a class="sourceLine" id="cb43-4" data-line-number="4"><span class="st">  </span><span class="kw">scale_x_continuous</span>(<span class="dt">breaks=</span> <span class="kw">seq</span>(<span class="dv">1960</span>, <span class="dv">2023</span>, <span class="dv">4</span>)) </a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-35-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
</p>
</div>
</div>
<div id="aforo-de-vehículos-revisado" class="section level2">
<h2><span class="header-section-number">7.3</span> Aforo de vehículos revisado</h2>
<p>Vamos a volver a identificar el <em>mejor</em> modelo ARIMA para la serie Aforo, pero cambiando el enfoque. La función de autoidentificación usa como criterio de optimalidad un criterio de ajuste (AIC, BIC). Si lo que deseamos es identificar el modelo con mejores predicciones extra-muestrales, hay que proceder de otra forma. Vamos seleccionar un conjunto amplio de modelos, vamos a estimar cada uno de ellos y vamos a calcular el error (MAPE) para previsones extra-muestrales según el horizonte temporal. El mejor modelo será el que cometa menor error de previsión para el horizonte temporal necesario.</p>
<p>El siguiente código define un total de 96 modelos, resultado de la combinación de los posibles valores del orden autoregresivo <span class="math inline">\(p = 0, 1, 2, 3\)</span>; el número de diferenciaciones <span class="math inline">\(d = 0, 1, 2\)</span>; los posibles valores del orden en medias móviles <span class="math inline">\(q = 0, 1, 2, 3\)</span> y el uso de la transformación logarítmica (sí/no).</p>
<p>Por simplicidad, hemos asumido que el modelo no tiene constante y no hemos incluido la intervención.</p>
<p>Por defecto, la función <code>Arima</code> solo estima modelos estacionarios. Para eludir esta restricción y que estime cualquier modelo, sea o no estacionario, hemos incluido el argumento <code>method = &quot;ML&quot;</code>.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" data-line-number="1">p &lt;-<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">3</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">d &lt;-<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb44-3" data-line-number="3">q &lt;-<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">3</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">l &lt;-<span class="st"> </span><span class="dv">0</span><span class="op">:</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb44-5" data-line-number="5">parametros &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(p,d,q,l)</a>
<a class="sourceLine" id="cb44-6" data-line-number="6"><span class="kw">colnames</span>(parametros) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;p&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;q&quot;</span>, <span class="st">&quot;log&quot;</span>)</a>
<a class="sourceLine" id="cb44-7" data-line-number="7"></a>
<a class="sourceLine" id="cb44-8" data-line-number="8">k &lt;-<span class="st"> </span><span class="dv">40</span>                 <span class="co">#Minimo numero de datos para estimar</span></a>
<a class="sourceLine" id="cb44-9" data-line-number="9">h &lt;-<span class="st">  </span><span class="dv">5</span>                 <span class="co">#Horizonte de las predicicones</span></a>
<a class="sourceLine" id="cb44-10" data-line-number="10">TT &lt;-<span class="st"> </span><span class="kw">length</span>(aforo)     <span class="co">#Longitud serie</span></a>
<a class="sourceLine" id="cb44-11" data-line-number="11">s &lt;-<span class="st"> </span>TT <span class="op">-</span><span class="st"> </span>k <span class="op">-</span><span class="st"> </span>h         <span class="co">#Total de estimaciones</span></a>
<a class="sourceLine" id="cb44-12" data-line-number="12"></a>
<a class="sourceLine" id="cb44-13" data-line-number="13">MAPE &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, <span class="kw">nrow</span>(parametros), h)</a>
<a class="sourceLine" id="cb44-14" data-line-number="14"></a>
<a class="sourceLine" id="cb44-15" data-line-number="15"><span class="cf">for</span> (para <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(parametros)) {</a>
<a class="sourceLine" id="cb44-16" data-line-number="16"></a>
<a class="sourceLine" id="cb44-17" data-line-number="17">  identificacion &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(parametros[para, <span class="op">-</span><span class="st"> </span><span class="dv">4</span>])</a>
<a class="sourceLine" id="cb44-18" data-line-number="18">  mapeArima &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>, s <span class="op">+</span><span class="st"> </span><span class="dv">1</span>, h)</a>
<a class="sourceLine" id="cb44-19" data-line-number="19">  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">0</span><span class="op">:</span>s) {</a>
<a class="sourceLine" id="cb44-20" data-line-number="20">    train.set &lt;-<span class="st"> </span><span class="kw">subset</span>(aforo, <span class="dt">start =</span> i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">end =</span> i <span class="op">+</span><span class="st"> </span>k)</a>
<a class="sourceLine" id="cb44-21" data-line-number="21">    test.set &lt;-<span class="st">  </span><span class="kw">subset</span>(aforo, <span class="dt">start =</span> i <span class="op">+</span><span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">end =</span> i <span class="op">+</span><span class="st"> </span>k <span class="op">+</span><span class="st"> </span>h)</a>
<a class="sourceLine" id="cb44-22" data-line-number="22">    </a>
<a class="sourceLine" id="cb44-23" data-line-number="23">    <span class="cf">if</span>(parametros[para, <span class="dv">4</span>] <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) </a>
<a class="sourceLine" id="cb44-24" data-line-number="24">      fit &lt;-<span class="st"> </span><span class="kw">Arima</span>(train.set, <span class="dt">order =</span> identificacion, <span class="dt">method =</span> <span class="st">&quot;ML&quot;</span>) <span class="cf">else</span> </a>
<a class="sourceLine" id="cb44-25" data-line-number="25">                     fit &lt;-<span class="st"> </span><span class="kw">Arima</span>(train.set, <span class="dt">order =</span> identificacion, </a>
<a class="sourceLine" id="cb44-26" data-line-number="26">                                  <span class="dt">lambda =</span> <span class="dv">0</span>, <span class="dt">method =</span> <span class="st">&quot;ML&quot;</span>)</a>
<a class="sourceLine" id="cb44-27" data-line-number="27">    fcast &lt;-<span class="st"> </span><span class="kw">forecast</span>(fit, <span class="dt">h =</span> h)</a>
<a class="sourceLine" id="cb44-28" data-line-number="28">    mapeArima[i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>,] &lt;-<span class="st"> </span><span class="dv">100</span><span class="op">*</span><span class="kw">abs</span>(test.set <span class="op">-</span><span class="st"> </span>fcast<span class="op">$</span>mean)<span class="op">/</span>test.set</a>
<a class="sourceLine" id="cb44-29" data-line-number="29">  }</a>
<a class="sourceLine" id="cb44-30" data-line-number="30">  </a>
<a class="sourceLine" id="cb44-31" data-line-number="31">  MAPE[para, ] &lt;-<span class="st"> </span><span class="kw">colMeans</span>(mapeArima)</a>
<a class="sourceLine" id="cb44-32" data-line-number="32"></a>
<a class="sourceLine" id="cb44-33" data-line-number="33">}</a>
<a class="sourceLine" id="cb44-34" data-line-number="34"></a>
<a class="sourceLine" id="cb44-35" data-line-number="35"><span class="co"># Mejores modelos si h = 1</span></a>
<a class="sourceLine" id="cb44-36" data-line-number="36">ii &lt;-<span class="st"> </span><span class="kw">order</span>(MAPE[, <span class="dv">1</span>], <span class="dt">decreasing =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb44-37" data-line-number="37"><span class="kw">cbind</span>(parametros[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>],], <span class="dt">error =</span> <span class="kw">round</span>(MAPE[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dv">1</span>], <span class="dv">3</span>))</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">p</th>
<th align="right">d</th>
<th align="right">q</th>
<th align="right">log</th>
<th align="right">error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>79</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">4.408</td>
</tr>
<tr class="even">
<td>59</td>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">4.598</td>
</tr>
<tr class="odd">
<td>23</td>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">4.654</td>
</tr>
</tbody>
</table>
</div>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="co"># Mejores modelos si h = 2</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2">ii &lt;-<span class="st"> </span><span class="kw">order</span>(MAPE[, <span class="dv">2</span>], <span class="dt">decreasing =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb45-3" data-line-number="3"><span class="kw">cbind</span>(parametros[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>],], <span class="dt">error =</span> <span class="kw">round</span>(MAPE[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dv">2</span>], <span class="dv">3</span>))</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">p</th>
<th align="right">d</th>
<th align="right">q</th>
<th align="right">log</th>
<th align="right">error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>87</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">8.085</td>
</tr>
<tr class="even">
<td>88</td>
<td align="right">3</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">8.718</td>
</tr>
<tr class="odd">
<td>64</td>
<td align="right">3</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">8.740</td>
</tr>
</tbody>
</table>
</div>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="co"># Mejores modelos si h = 3</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2">ii &lt;-<span class="st"> </span><span class="kw">order</span>(MAPE[, <span class="dv">3</span>], <span class="dt">decreasing =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb46-3" data-line-number="3"><span class="kw">cbind</span>(parametros[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>],], <span class="dt">error =</span> <span class="kw">round</span>(MAPE[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dv">3</span>], <span class="dv">3</span>))</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">p</th>
<th align="right">d</th>
<th align="right">q</th>
<th align="right">log</th>
<th align="right">error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>87</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">10.754</td>
</tr>
<tr class="even">
<td>88</td>
<td align="right">3</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">10.765</td>
</tr>
<tr class="odd">
<td>64</td>
<td align="right">3</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">11.390</td>
</tr>
</tbody>
</table>
</div>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="co"># Mejores modelos si h = 4</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">ii &lt;-<span class="st"> </span><span class="kw">order</span>(MAPE[, <span class="dv">4</span>], <span class="dt">decreasing =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb47-3" data-line-number="3"><span class="kw">cbind</span>(parametros[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>],], <span class="dt">error =</span> <span class="kw">round</span>(MAPE[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dv">4</span>], <span class="dv">3</span>))</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">p</th>
<th align="right">d</th>
<th align="right">q</th>
<th align="right">log</th>
<th align="right">error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>87</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">14.494</td>
</tr>
<tr class="even">
<td>88</td>
<td align="right">3</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">15.064</td>
</tr>
<tr class="odd">
<td>64</td>
<td align="right">3</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">15.650</td>
</tr>
</tbody>
</table>
</div>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="co"># Mejores modelos si h = 5</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2">ii &lt;-<span class="st"> </span><span class="kw">order</span>(MAPE[, <span class="dv">5</span>], <span class="dt">decreasing =</span> <span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb48-3" data-line-number="3"><span class="kw">cbind</span>(parametros[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>],], <span class="dt">error =</span> <span class="kw">round</span>(MAPE[ii[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>], <span class="dv">5</span>], <span class="dv">3</span>))</a></code></pre></div>
<div class="kable-table">
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">p</th>
<th align="right">d</th>
<th align="right">q</th>
<th align="right">log</th>
<th align="right">error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>87</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">18.746</td>
</tr>
<tr class="even">
<td>63</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">19.225</td>
</tr>
<tr class="odd">
<td>88</td>
<td align="right">3</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">19.556</td>
</tr>
</tbody>
</table>
</div>
<p>Las tablas identifican los tres mejores modelos según que el orden de previsión de interés, desde uno a cinco años.</p>
<ul>
<li>Para previsiones a un año vista el mejor modelo es <span class="math inline">\(log(Aforo_t) \sim ARIMA(2,1,2)\)</span>. Aunque los otros dos modelos mostrados resultan equivalentes.</li>
<li>Para previsiones a más de un año vista el mejor modelo es <span class="math inline">\(log(Aforo_t) \sim ARIMA(2,0,3)\)</span>, en ocasiones muy superior al siguiente <em>mejor</em> modelo.</li>
<li>Ninguno de los modelo que mejores predicciones generan es el que mejor ajusta a los datos.</li>
</ul>
<p><br />
</p>
</div>
<div id="consumo-de-alimentos-en-el-hogar-per-cápita" class="section level2">
<h2><span class="header-section-number">7.4</span> Consumo de alimentos en el hogar per cápita</h2>
<p>Analizaremos el <strong>consumo alimentario en hogar per cápita</strong> en España. Esta serie está construida a partir de la serie de consumo alimentario en hogar (disponible en el Ministerio de Agricultura, Alimentación y Medio Ambiente), y la serie de población (disponible en el Instituto Nacional de Estadística). Es una serie anual de 1987 a 2018 (32 datos) y la unidad es el Kg per cápita. La figura 23 muestra que es una serie muy irregular, con cambios de tendencia constantes.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1">alimentospc &lt;-<span class="st"> </span><span class="kw">read.csv2</span>(<span class="st">&quot;./series/alimentacionpc.csv&quot;</span>, <span class="dt">header =</span> <span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb49-2" data-line-number="2">alimentospc &lt;-<span class="st"> </span><span class="kw">ts</span>(alimentospc, <span class="dt">start =</span> <span class="dv">1987</span>, <span class="dt">freq =</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb49-3" data-line-number="3">    </a>
<a class="sourceLine" id="cb49-4" data-line-number="4"><span class="kw">autoplot</span>(alimentospc, </a>
<a class="sourceLine" id="cb49-5" data-line-number="5">         <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, </a>
<a class="sourceLine" id="cb49-6" data-line-number="6">         <span class="dt">ylab =</span> <span class="st">&quot;Kg per cápita&quot;</span>,</a>
<a class="sourceLine" id="cb49-7" data-line-number="7">         <span class="dt">main =</span> <span class="st">&quot;Figura 16. Consumo alimentario en hogar&quot;</span>)</a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-37-1.png" width="80%" style="display: block; margin: auto;" /></p>
<div id="transformación-de-la-serie-2" class="section level3 unnumbered">
<h3>Transformación de la serie</h3>
<p>La figura 17 indica que la serie original ya es estacionaria y la función <code>ndiffs</code> lo corrobora. Por tanto asumimos que <span class="math inline">\(d=0\)</span> o <span class="math inline">\(alimentospc_t \sim I(0)\)</span>.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">autoplot</span>(alimentospc, <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Alimentos&quot;</span>)</a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="kw">autoplot</span>(<span class="kw">diff</span>(alimentospc), <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;Diferencia alimentos&quot;</span>)</a>
<a class="sourceLine" id="cb50-3" data-line-number="3"><span class="kw">ggAcf</span>(alimentospc, <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;FAC&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb50-4" data-line-number="4"><span class="kw">ggAcf</span>(<span class="kw">diff</span>(alimentospc), <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;FAC&quot;</span>, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>)</a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-39-1.png" width="80%" style="display: block; margin: auto;" /></p>
</div>
<div id="identificación-2" class="section level3 unnumbered">
<h3>Identificación</h3>
<p>Para identificar los valores de <span class="math inline">\(p\)</span> y <span class="math inline">\(q\)</span> veremos que nos sugiere <code>auto.arima</code> :</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">auto.arima</span>(alimentospc)</a></code></pre></div>
<pre><code>Series: alimentospc 
ARIMA(1,0,0) with non-zero mean 

Coefficients:
         ar1      mean
      0.6477  639.2512
s.e.  0.1561    5.7083

sigma^2 estimated as 153:  log likelihood=-125.13
AIC=256.26   AICc=257.12   BIC=260.66</code></pre>
<p>La identificación automática sugiere un proceso AR(1) con constante y ambos coeficientes parecen significativos.</p>
<p>Vamos a ver la gráfica de los residuos de este proceso para identificar rápidamente si hay valores extremos (figura 18).</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1">arima100 &lt;-<span class="st"> </span><span class="kw">Arima</span>(alimentospc, </a>
<a class="sourceLine" id="cb53-2" data-line-number="2">                  <span class="dt">order =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb53-3" data-line-number="3"></a>
<a class="sourceLine" id="cb53-4" data-line-number="4">error &lt;-<span class="st"> </span><span class="kw">residuals</span>(arima100)</a>
<a class="sourceLine" id="cb53-5" data-line-number="5">sderror &lt;-<span class="st"> </span><span class="kw">sd</span>(error)</a>
<a class="sourceLine" id="cb53-6" data-line-number="6"></a>
<a class="sourceLine" id="cb53-7" data-line-number="7"><span class="kw">autoplot</span>(error, <span class="dt">series=</span><span class="st">&quot;Error&quot;</span>,</a>
<a class="sourceLine" id="cb53-8" data-line-number="8">         <span class="dt">colour =</span> <span class="st">&quot;black&quot;</span>,</a>
<a class="sourceLine" id="cb53-9" data-line-number="9">         <span class="dt">xlab =</span> <span class="st">&quot;&quot;</span>,</a>
<a class="sourceLine" id="cb53-10" data-line-number="10">         <span class="dt">ylab =</span> <span class="st">&quot;Error&quot;</span>,</a>
<a class="sourceLine" id="cb53-11" data-line-number="11">         <span class="dt">main =</span> <span class="st">&quot;Figura 18. Error + Intervención&quot;) +</span></a>
<a class="sourceLine" id="cb53-12" data-line-number="12"><span class="st">  geom_hline(yintercept = c(-3, -2, 2, 3)*sderror, </span></a>
<a class="sourceLine" id="cb53-13" data-line-number="13"><span class="st">             colour = c(&quot;</span>red<span class="st">&quot;, &quot;</span>green<span class="st">&quot;, &quot;</span>green<span class="st">&quot;, &quot;</span>red<span class="st">&quot;), </span></a>
<a class="sourceLine" id="cb53-14" data-line-number="14"><span class="st">             lty = 2) + </span></a>
<a class="sourceLine" id="cb53-15" data-line-number="15"><span class="st">  geom_point() +</span></a>
<a class="sourceLine" id="cb53-16" data-line-number="16"><span class="st">  scale_x_continuous(breaks= seq(1987, 2018, 3)) </span></a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-41-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Ningún residuo supera las 2.5 desviaciones típicas así que consideraremos que <span class="math inline">\(alimentospc_t \sim ARIMA(1,0,0)\)</span>.</p>
</div>
<div id="coeficientes-significativos" class="section level3 unnumbered">
<h3>Coeficientes significativos</h3>
<p>Tanto <span class="math inline">\(\phi_1\)</span> como <span class="math inline">\(\mu\)</span> (la constante del modelo) son significativos.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">wald.test</span>(<span class="dt">b =</span> <span class="kw">coef</span>(arima100), <span class="dt">Sigma =</span> <span class="kw">vcov</span>(arima100), <span class="dt">Terms =</span> <span class="dv">1</span>)</a></code></pre></div>
<pre><code>Wald test:
----------

Chi-squared test:
X2 = 17.2, df = 1, P(&gt; X2) = 0.000033</code></pre>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">wald.test</span>(<span class="dt">b =</span> <span class="kw">coef</span>(arima100), <span class="dt">Sigma =</span> <span class="kw">vcov</span>(arima100), <span class="dt">Terms =</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>Wald test:
----------

Chi-squared test:
X2 = 12540.9, df = 1, P(&gt; X2) = 0.0</code></pre>
</div>
<div id="medidas-de-error-2" class="section level3 unnumbered">
<h3>Medidas de error</h3>
<p>El error medio es 12 Kg per cápita (RMSE) y el error porcentual medio (MAPE) es 1.37%.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="kw">accuracy</span>(arima100)</a></code></pre></div>
<pre><code>                ME  RMSE  MAE   MPE MAPE MASE ACF1
Training set -0.96 11.98 8.79 -0.18 1.37 0.93 0.01</code></pre>
</div>
<div id="interpretación-del-modelo-1" class="section level3 unnumbered">
<h3>Interpretación del modelo</h3>
<p>El <strong>modelo teórico</strong> identificado es <span class="math inline">\(alimentospc_t \sim ARIMA(1,0,0)\)</span> + constante: <span class="math display">\[(1 - \phi_1 L) alimentospc_t = c + \varepsilon_t,\]</span></p>
<p>que desarrollando queda: <span class="math display">\[alimentospc_t = c + \phi_1 alimentospc_{t-1}+ \varepsilon_t.\]</span></p>
<p>Finalmente. el <strong>modelo estimado</strong> es: <span class="math display">\[\widehat{alimentospc}_t = 225.21 + 0.65 \cdot alimentospc_{t-1}\]</span></p>
<p><strong>Observación</strong>: El término contante <span class="math inline">\(\mu\)</span> que estima R no el valor de “c” que hemos visto en la teoría. Para convertir la contante estimada por R en “c” hemos de multiplicarla por el polinomio autoregresivo. En este caso, <span class="math display">\[c = \mu \cdot (1 - \phi_1) = 639.2512\cdot(1 - 0.6477) = 225.2082.\]</span></p>
<p>Cada año el consumo de alimentos per cápita en el hogar es 225 kilos más un 65% del consumo del año pasado.</p>
</div>
<div id="predicciones-de-la-serie" class="section level3 unnumbered">
<h3>Predicciones de la serie</h3>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1">parima100 &lt;-<span class="st"> </span><span class="kw">forecast</span>(arima100, <span class="dt">h =</span> <span class="dv">5</span>, <span class="dt">level =</span> <span class="dv">95</span>)</a>
<a class="sourceLine" id="cb60-2" data-line-number="2">parima100</a></code></pre></div>
<pre><code>     Point Forecast    Lo 95    Hi 95
2019       624.7740 600.5313 649.0167
2020       629.8742 600.9905 658.7579
2021       633.1776 602.5556 663.7996
2022       635.3173 603.9947 666.6399
2023       636.7032 605.0913 668.3150</code></pre>
<p>Puedes comprobar que cada valor de la predicción se ha obtenido a partir del modelo estimado, donde <span class="math inline">\(alimentospc_{t-1}\)</span> se sustituye por la predicción del año precedente.</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb62-1" data-line-number="1"><span class="kw">autoplot</span>(parima100, </a>
<a class="sourceLine" id="cb62-2" data-line-number="2">     <span class="dt">ylab =</span> <span class="st">&quot;Kilos per cápita&quot;</span>,</a>
<a class="sourceLine" id="cb62-3" data-line-number="3">     <span class="dt">main =</span> <span class="st">&quot;Figura 19. Consumo de alimentos y predicción&quot;) +</span></a>
<a class="sourceLine" id="cb62-4" data-line-number="4"><span class="st">  scale_x_continuous(breaks= seq(1987, 2023, 4)) </span></a></code></pre></div>
<p><img src="03-06-Tema6_files/figure-html/unnamed-chunk-46-1.png" width="80%" style="display: block; margin: auto;" /></p>
<p><br />
</p>
</div>
</div>
<div id="comparación-con-alisado-exponencial" class="section level2">
<h2><span class="header-section-number">7.5</span> Comparación con alisado exponencial</h2>
<p>Veamos una comparativa, para los tres ejemplos vistos, entre los resultados obtenidos con ARIMA y con Alisado exponencial.</p>
<ul>
<li>Libros:
<ul>
<li><p>MAPE ARIMA: <span class="math inline">\(7.02\%\)</span> - ARIMA(0,1,0) sin deriva</p></li>
<li><p>MAPE ETS: <span class="math inline">\(7.05\%\)</span> - ETS(M,N,N), <span class="math inline">\(\alpha=1\)</span></p></li>
<li><p>Ambos métodos han estimado el mismo modelo.</p></li>
</ul></li>
</ul>

<ul>
<li>Aforo (log):
<ul>
<li><p>MAPE ARIMA: <span class="math inline">\(5.24\%\)</span> - ARIMA(1,2,0) sin deriva, con intervención</p></li>
<li><p>MAPE ETS: <span class="math inline">\(5.73\%\)</span> - ETS(A,Ad,N), <span class="math inline">\(\alpha=0.57\)</span>, <span class="math inline">\(\beta=0.57\)</span>, <span class="math inline">\(\phi = 0.85\)</span></p></li>
<li><p>Cada método estima un modelo diferente</p></li>
<li><p>ARIMA tiene menor error a costa de incluir cuatro variables de intervención</p></li>
</ul></li>
</ul>

<ul>
<li>Alimentos per cápita:
<ul>
<li><p>MAPE ARIMA: <span class="math inline">\(1.37\)</span> - ARIMA(1,0,0) con constante</p></li>
<li><p>MAPE ETS: <span class="math inline">\(1.43\)</span> - ETS(M,N,N), <span class="math inline">\(\alpha = 1\)</span></p></li>
<li><p>Cada método ha estimado un modelo diferente, pero con una bondad de ajuste similar.</p></li>
</ul></li>
</ul>
<p><br />
<br />
</p>
</div>
</div>
<div id="resumen-de-los-comandos-utilizados" class="section level1">
<h1><span class="header-section-number">8</span> Resumen de los comandos utilizados</h1>
<table>
<thead>
<tr class="header">
<th align="left">Función</th>
<th align="left">Paquete</th>
<th align="left">Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Arima</code></td>
<td align="left">forecast</td>
<td align="left">estima un proceso ARIMA</td>
</tr>
<tr class="even">
<td align="left"><code>auto.arima</code></td>
<td align="left">forecast</td>
<td align="left">identificación automática de un modelo ARIMA</td>
</tr>
<tr class="odd">
<td align="left"><code>wald.test</code></td>
<td align="left">aod</td>
<td align="left">contrasta la significatividad conjunta de varios parámetros</td>
</tr>
<tr class="even">
<td align="left"><code>forecast</code></td>
<td align="left">forecast</td>
<td align="left">realiza una predicción de un modelo</td>
</tr>
</tbody>
</table>
<p><br />
<br />
</p>
</div>
<div id="referencias" class="section level1">
<h1><span class="header-section-number">9</span> Referencias</h1>
<ul>
<li>Box, G. E.P. y Jenkins, G. (1976). <em>Time Series Analysis: Forecasting and Control</em> Editado por Holden-Day, San Francisco, CA</li>
</ul>
<p><br />
<br />
<br />
<br />
</p>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiUHJvY2Vzb3MgQVJJTUEiCnN1YnRpdGxlOiAiUHJldmlzacOzbiBjb24gRGF0b3MgVGVtcG9yYWxlcyAoR0JJQSkiCmF1dGhvcjogIkl2w6FuIEFycmliYXMgKERlcHRvLiBBbsOhbGlzaXMgRWNvbsOzbWljby4gVW5pdmVyc2l0YXQgZGUgVmFsw6huY2lhKSIKZGF0ZTogIkN1cnNvIDIwMjAtMjEiCm91dHB1dDogCiAgaHRtbF9kb2N1bWVudDoKICAgIGNvZGVfZG93bmxvYWQ6IHllcwogICAgZGZfcHJpbnQ6IGthYmxlCiAgICBmaWdfY2FwdGlvbjogbm8KICAgIGhpZ2hsaWdodDogcHlnbWVudHMKICAgIG51bWJlcl9zZWN0aW9uczogeWVzCiAgICBzZWxmX2NvbnRhaW5lZDogeWVzCiAgICB0aGVtZTogY2VydWxlYW4KICAgIHRvYzogeWVzCiAgICB0b2NfZGVwdGg6IDIKICAgIHRvY19mbG9hdDoKICAgICAgY29sbGFwc2VkOiB5ZXMKLS0tCgpgYGB7ciBjaHVua19zZXR1cCwgZWNobyA9IEZBTFNFfQprbml0cjo6b3B0c19jaHVuayRzZXQod2FybmluZyA9IEZBTFNFLCAKICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBGQUxTRSwgCiAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gIiIsCiAgICAgICAgICAgICAgICAgICAgICBmaWcuYWxpZ24gPSAiY2VudGVyIiwgCiAgICAgICAgICAgICAgICAgICAgICBmaWcuc2hvdyA9ICJob2xkIiwKICAgICAgICAgICAgICAgICAgICAgIGZpZy5oZWlnaHQgPSA0LAogICAgICAgICAgICAgICAgICAgICAgZmlnLndpZHRoID0gOCwKICAgICAgICAgICAgICAgICAgICAgIG91dC53aWR0aCA9ICI4MCUiKSAKYGBgCgpgYGB7ciBvcHRpb25zX3NldHVwLCBlY2hvID0gRkFMU0V9Cm9wdGlvbnMoc2NpcGVuID0gOTk5KSAjLSBwYXJhIHF1aXRhciBsYSBub3RhY2lvbiBjaWVudGlmaWNhCmBgYAoKYGBge3IgbGlicmVyaWFzLCBlY2hvID0gRkFMU0V9CmxpYnJhcnkoZm9yZWNhc3QpCmxpYnJhcnkoZ2dwbG90Mik7IHRoZW1lX3NldCh0aGVtZV9idygpKQpsaWJyYXJ5KGdyaWRFeHRyYSkKbGlicmFyeShncmlkKQpsaWJyYXJ5KGFvZCkKYGBgCgoKIyBJbnRyb2R1Y2Npw7NuCgpMb3MgX19tb2RlbG9zIEFSSU1BX18gaGFuIG1vc3RyYWRvIHNlciB1bm8gc2UgbG9zIG3DqXRvZG9zIGRlIGFqdXN0ZSBkZSBzZXJpZXMgdGVtcG9yYWxlcyBtw6FzIHZhbGlvc29zIGRlc2RlIHF1ZSBmdWVyYW4gZm9ybWFsaXphZG9zIGVuIDE5NzYgcG9yIEJveCB5IEplbmtpbnMsIGVuIHN1IGxpYnJvIFsqVGltZSBzZXJpZXMgYW5hbHlzaXMsIGZvcmVjYXN0aW5nIGFuZCBjb250cm9sKl0oaHR0cDovL3d3dy5hbWF6b24uY29tL1RpbWUtQW5hbHlzaXMtRm9yZWNhc3RpbmctR2VvcmdlLUJveC9kcC8wNDcwMjcyODQ4KS4gQWRlbcOhcywgZGllcm9uIGxhcyBwYXV0YXMgYSBzZWd1aXIgZW4gZWwgYWp1c3RlIGRlIHVuYSBzZXJpZSB0ZW1wb3JhbCBwYXJhIGFsY2FuemFyIGJ1ZW5hcyBwcmVkaWNjaW9uZXMgKHbDqWFzZSBlcMOtZ3JhZmUgNikuCgpFbiBlc3RlIHRlbWEsIHkgZWwgc2lndWllbnRlLCBkZWZpbmlyZW1vcyBlc3RvcyBwcm9jZXNvcyB5IGFwcmVuZGVyZW1vcyBhIGlkZW50aWZpY2FybG9zLCBlc3RpbWFybG9zIHkgaGFjZXIgcHJlZGljY2lvbmVzLgoKX19Mb3MgcHJvY2Vzb3MgQVJJTUEgc29uIGFob3JhIGVsIHRyb25jbyBkZSB1bmEgYW1wbGlhIGZhbWlsaWEgZGUgcHJvY2Vzb3NfXyBxdWUgcmVxdWllcmVuIG1lbm9zIGhpcMOzdGVzaXMgcGFyYSBzdSBhcGxpY2FjacOzbiBvIGFqdXN0YW4gbWVqb3IgYmFqbyBkaWZlcmVudGVzIGhpcMOzdGVzaXM6IEFSQ0gsIEdBUkNILCBOR0FSQ0gsICBJR0FSQ0gsIEVHQVJDSCwgR0FSQ0gtTSwgUUdBUkNILCBHSlItR0FSQ0gsIFRHQVJDSCwgZkdBUkNILi4uCgpfX0xvcyBwcm9jZXNvcyBBUklNQSB5IGxvcyBtw6l0b2RvcyBkZSBBbGlzYWRvIEV4cG9uZW5jaWFsIHNvbiBjb21wbGVtZW50YXJpb3NfXzoKCiogTG9zIG1vZGVsb3MgZGUgQWxpc2FkbyBsaW5lYWxlcyBzb24gY2Fzb3MgZXNwZWNpYWxlcyBkZSBtb2RlbG9zIEFyaW1hLAoqIExvcyBtb2RlbG9zIGRlIEFsaXNhZG8gbm8gbGluZWFsZXMgbm8gdGllbmVuIHN1IGNvbnRyYXBhcnRpZGEgZW4gbW9kZWxvcyBBcmltYQoqIE11Y2hvcyBtb2RlbG9zIEFyaW1hIG5vIHRpZW5lIGNvbnRyYXBhcnRpZGEgZW4gbG9zIG1vZGVsb3MgZGUgQWxpc2Fkby4gIAoKUGVybyBhbnRlcyBkZSBlbnRyYXIgZW4gbWF0ZXJpYSBlcyBuZWNlc2FyaW8gZGVmaW5pciB1bmEgc2VyaWUgZGUgY29uY2VwdG9zIHF1ZSBwZXJtaXRpcsOhbiBlbnRlbmRlciBtZWpvciBfX3VuYSBzZXJpZSB0ZW1wb3JhbCBjb21vIHVuYSBtdWVzdHJhIGRlIHVuIHByb2Nlc28gZ2VuZXJhZG9yIGRlIGRhdG9zX18gKFBHRCkuIAoKXApcCgojIFByb2Nlc28gZXN0b2PDoXN0aWNvCgpcCgojIyBEZWZpbmljacOzbiBlIGhpcMOzdGVzaXMgc29icmUgZWwgcHJvY2VzbwoKVW4gX19wcm9jZXNvIGVzdG9jw6FzdGljb19fICRZX3QkIGVzIChzaW4gZXhjZXNpdmEgcHJlY2lzacOzbikgdW5hIHZhcmlhYmxlIGFsZWF0b3JpYSBxdWUgY29ycmVzcG9uZGUgYSBtb21lbnRvcyBzdWNlc2l2b3MgZGVsIHRpZW1wby4gQSBkaWZlcmVuY2lhIGRlIGxvcyB0ZW1hcyBwcmV2aW9zLCBlbiBlc3RlIHZhbW9zIGEgZXN0aW1hciBtb2RlbG9zIHNvYnJlIHByb2Nlc29zIGVzdG9jw6FzdGljb3MuIFNlcsOtYSBlbCBlcXVpdmFsZW50ZSBwYXJhIHNlcmllcyB0ZW1wb3JhbGVzIGFsIG1vZGVsbyBkZSByZWdyZXNpw7NuIGxpbmVhbCBxdWUgdmlzdGUgZW4gZWwgcHJpbWVyIHNlbWVzdHJlIHBhcmEgZGF0b3MgdHJhbnN2ZXJzYWxlcy4KCkFsIGlndWFsIHF1ZSBlbiBfUHJlZGljY2nDs24gY29uIGRhdG9zIHRyYW5zdmVyc2FsZXNfLCBsYSBhcGxpY2FjacOzbiBkZSBlc3RvcyBtb2RlbG9zIHJlcXVpZXJlIGRlbCBjdW1wbGltaWVudG8gZGUgdW5hIHNlcmllIGRlIGhpcMOzdGVzaXMuIFBhcmEgZWwgY2FzbyBkZSBzZXJpZXMgdGVtcG9yYWxlcyBlbCBwcm9jZXNvIGRlYmUgc2VyIF9fbm9ybWFsX18sIF9fZXN0YWNpb25hcmlvX18geSBfX2VyZ8OzZGljb19fLgogIApcCiAgCiMjIyBQcm9jZXNvIGVzdGFjaW9uYXJpbwoKVW4gcHJvY2VzbyBlcyBfX2VzdGFjaW9uYXJpbyBlbiBzZW50aWRvIGVzdHJpY3RvX18gY3VhbmRvIGxhIGRpc3RyaWJ1Y2nDs24gY29uanVudGEgbm8gdmFyw61hIGFsIHJlYWxpemFyIHVuIGRlc3BsYXphbWllbnRvIGVuIGVsIHRpZW1wbyBkZSB0b2RhcyBsYXMgdmFyaWFibGVzLgoKKiBTaSAkRihZX3t0XzF9LC4uLiwgWV97dF9rfSkkIGVzIGxhIGZ1bmNpw7NuIGRlIGRpc3RyaWJ1Y2nDs24gY29uanVudGEgeSAkaD4wJCwgZW50b25jZXMgZWwgcHJvY2VzbyBlcyBlc3RhY2lvbmFyaW8gZW4gc2VudGlkbyBlc3RyaWN0byBzaQokJEYoWV97dF8xfSwuLi4sIFlfe3Rfa30pID0gRihZX3t0XzEraH0sLi4uLCBZX3t0X2sraH0pJCQKICAgICAgCkludHVpdGl2YW1lbnRlLCBfbGEgZGlzdHJpYnVjacOzbiBkZSB1biBwcm9jZXNvIGVzdG9jw6FzdGljbyBlcyBpbmRlcGVuZGllbnRlIGRlbCBtb21lbnRvIGRlbCB0aWVtcG9fLgoKQ29tcHJvYmFyIHNpIHVuIHByb2Nlc28gZXMgZXN0YWNpb25hcmlvIGVuIHNlbnRpZG8gZXN0cmljdG8gZXMgbXV5IGRpZsOtY2lsLCBhc8OtIHF1ZSB2YW1vcyBhIGVuY29udHJhciBjb25kaWNpb25lcyBzdWZpY2llbnRlczogX2VzdGFjaW9uYXJpZWRhZCBlbiBtZWRpYV8geSBlbiBfc2VudGlkbyBhbXBsaW9fIChjb3ZhcmlhbnphKS4gKipCYWpvIG5vcm1hbGlkYWQqKiB1biBwcm9jZXNvIGVzdGFjaW9uYXJpbyBlbiBzZW50aWRvIGFtcGxpbyB0YW1iacOpbiBsbyBzZXLDoSBlbiBzZW50aWRvIGVzdHJpY3RvLgoKKipQcm9jZXNvIGVzdGFjaW9uYXJpbyBlbiBtZWRpYSoqCgpVbiBwcm9jZXNvIGVzIGVzdGFjaW9uYXJpbyBlbiBtZWRpYSAobyBkZSBwcmltZXIgb3JkZW4pIHNpIHN1IG5pdmVsIHNlIG1hbnRpZW5lIGVuIGVsIHRpZW1wbzoKJCRFW1lfdF0gPSBcbXUgXDsgXDsgXGZvcmFsbCB0JCQKCioqUHJvY2VzbyBlc3RhY2lvbmFyaW8gZW4gc2VudGlkbyBhbXBsaW8qKgoKVW4gcHJvY2VzbyAoeWEgZXN0YWNpb25hcmlvIGVuIG1lZGlhKSBlcyBlc3RhY2lvbmFyaW8gZW4gc2VudGlkbyBhbXBsaW8sIG8gZGUgc2VndW5kbyBvcmRlbiwgc2kgc3VzIG1vbWVudG9zIGRlIG9yZGVuIGRvcyBubyBkZXBlbmRlbiBkZWwgdGllbXBvOgoKKiBMYSAoYXV0byljb3ZhcmlhbnphIGVudHJlIGRvcyBwZXJpb2RvcyBkZSB0aWVtcG8gZXMgZmluaXRhIHkgc8OzbG8gZGVwZW5kZSBkZWwgaW50ZXJ2YWxvIGRlIHRpZW1wbyB0cmFuc2N1cnJpZG8gZW50cmUgZXN0b3MgZG9zIHBlcmlvZG9zOgokJENvdltZX3QsIFlfe3Qra31dID0gRVsoWV90IC0gXG11KShZX3t0K2t9IC0gXG11KV0gPSBcZ2FtbWFfayxcLFwsXCxcZm9yYWxsIHQkJAoKT2JzZXJ2YSBxdWUgbGEgdmFyaWFuemEgc2Vyw6EgZW50b25jZXMgJFZhcltZX3RdID0gRVsoWV90IC0gXG11KV4yXSA9IFxnYW1tYV8wJC4KClwKCkxhIGZpZ3VyYSAxIG11ZXN0cmEgbGEgc2VyaWUgTmFjaW1pZW50b3MgcXVlIG5vIGVzIGVzdGFjaW9uYXJpYSBuaSBlbiBtZWRpYSwgbmkgZW4gdmFyaWFuemEuIE5vIGxvIGVzIGVuIG1lZGlhIHBvciBxdWUgcHJlc2VudGEgbGFyZ29zIHBlcmlvZG9zIGRlIHRlbmRlbmNpYSBjcmVjaWVudGUgeSBkZWNyZWNpZW50ZTsgeSBubyBsbyBlcyBlbiB2YXJpYW56YSBwb3IgcXVlIGFsIGluaWNpbyBkZSBsYSBzZXJpZSBsb3MgZGF0b3MgcHJlc2VudG5hIG3DoXMgdmFyaWFiaWxpZGFkIHF1ZSBhIGZpbmFsZXMgZGVsIHNpZ2xvIHBhc2Fkby4gCgpgYGB7ciwgZWNobz1GQUxTRX0KbmFjaW1pZW50b3MgPC0gcmVhZC5jc3YyKCIuL3Nlcmllcy9uYWNpbWllbnRvcy5jc3YiLCBoZWFkZXIgPSBUUlVFKQpuYWNpbWllbnRvcyA8LSB0cyhuYWNpbWllbnRvc1ssIDJdLAogICAgICAgICAgICAgICAgICBzdGFydCA9IGMoMTk3NSwgMSksCiAgICAgICAgICAgICAgICAgIGZyZXEgPSAxMikKCmF1dG9wbG90KG5hY2ltaWVudG9zLAogICAgICAgICB4bGFiID0gIiIsCiAgICAgICAgIHlsYWIgPSAiTmFjaW1pZW50b3MiLAogICAgICAgICBtYWluID0gIkZpZ3VyYSAxLiBOYWNpbWllbnRvcyBtZW5zdWFsZXMiKQpgYGAKCgoqKlByb2Nlc28gZXJnw7NkaWNvKioKClBhcmEgcXVlIHVuIHByb2Nlc28gc2VhIGVyZ8OzZGljbyBsYXMgb2JzZXJ2YWNpb25lcyBudWV2YXMgdGllbmVuIHF1ZSBhcG9ydGFyIHN1ZmljaWVudGUgaW5mb3JtYWNpw7NuIHBhcmEgcXVlIGxhIHZhcmlhbnphIGRlbCB2YWxvciBtZWRpbyBjb252ZXJqYSBhIDAuIEVzdG8gbm8gb2N1cnJlIHNpIGxhIGRlcGVuZGVuY2lhIGVudHJlIGxhcyB2YXJpYWJsZXMgZXMgbXV5IGZ1ZXJ0ZS4KClVuYSBjb25kaWNpw7NuIG5lY2VzYXJpYSBwZXJvIG5vIHN1ZmljaWVudGUgcGFyYSBxdWUgdW4gcHJvY2VzbyBlc3RhY2lvbmFyaW8gc2VhIGVyZ8OzZGljbyBlczoKJCRcbGltX3trXHJpZ2h0YXJyb3cgXGluZnR5fSBcZ2FtbWFfayA9IDAuJCQKClwKXAoKIyBUcmFuc2Zvcm1hY2lvbmVzIGRlIHVuYSBzZXJpZQoKXAoKIyMgSWRlYXMgZ2VuZXJhbGVzCgpVbmEgc2VyaWUgdGVtcG9yYWwgJFx7eV90XH1fe3Q9MX1eVCQgbm8gdGllbmUgcG9ycXVlIHZlcmlmaWNhciBsYXMgY29uZGljaW9uZXMgZGUgZXN0YWNpb25hcmllZGFkIHkgZXJnb2RpY2lkYWQuIEEgY29udGludWFjacOzbiwgdmVyZW1vcyB1bmEgc2VyaWUgZGUgdHJhbnNmb3JtYWNpb25lcyBxdWUgY29udmllcnRlbiB1bmEgc2VyaWUgbm8gZXN0YWNpb25hcmlhIGVuIGVzdGFjaW9uYXJpYTsgbm8gZXJnw7NkaWNhIGVuIGVyZ8OzZGljYTsgeSwgZGUgcGFzbywgZmFjaWxpdGFuIGxhIHZlcmlmaWNhY2nDs24gZGUgbGEgaGlww7N0ZXNpcyBkZSBub3JtYWxpZGFkLCBxdWUgZGVqYXJlbW9zIHBhcmEgbcOhcyBhZGVsYW50ZS4KICAKRW4gZWwgcGFuZWwgc3VwZXJpb3IgZGUgbGEgZmlndXJhIDIgdnVlbHZlcyBhIHRlbmVyIGxhIHNlcmllIGRlIG5hY2ltaWVudG9zLCBxdWUgZGVub21pbmFyZW1vcyAkeV90JCwgeSBlbiBwYW5lbCBpbmZlcmlvciB0aWVuZXMgbGEgZGlmZXJlbmNpYSBkZSBsYSB0cmFuc2Zvcm1hY2nDs24gbG9nYXLDrXRtaWNhIGRlIGxhIHNlcmllLCAkbG9nKHlfdCkgLSBsb2coeV97dC0xfSkkLiBMYSBzZXJpZSBuYWNpbWllbnRvcyBubyBlcyBlc3RhY2lvbmFyaWEgZW4gbWVkaWEgbmkgZW4gdmFyaWFuemEsIHBlcm8gbGEgdHJhbnNmb3JtYWNpw7NuIGxvZ2Fyw610bWljYSB5IGxhIGRpZmVyZW5jaWEgaGFuIGxvZ3JhZG8gcXVlIHNlYSBlc3RhY2lvbmFyaWEgZW4gYW1ib3Mgc2VudGlkb3MuCgpgYGB7ciwgZWNobz1GQUxTRX0KY2JpbmQoIk5hY2lkb3MiID0gbmFjaW1pZW50b3MsCiAgICAgICJEaWYuIGRlIGxvZyBuYWNpZG9zIiA9IGRpZmYobG9nKG5hY2ltaWVudG9zKSkpICU+JQogIGF1dG9wbG90KGZhY2V0cyA9IFRSVUUsCiAgICAgICAgICAgeGxhYiA9ICIiLAogICAgICAgICAgIHlsYWIgPSAiIiwKICAgICAgICAgICBtYWluID0gIkZpZ3VyYSAyLiBOYWNpbWllbnRvcyB5IGRpZmVyZW5jaWEgZGVsIGxvZ2FyaXRtbyBkZSBOYWNpbWllbnRvcyIpCmBgYAoKXAoKIyMgRGlmZXJlbmNpYWNpw7NuCgpfX0xhIGRpZmVyZW5jaWFjacOzbiBwZXJtaXRlIHRyYW5zZm9ybWFyIHVuYSBzZXJpZSBubyBlc3RhY2lvbmFyaWEgZW4gbWVkaWEgZW4gZXN0YWNpb25hcmlhIGVuIG1lZGlhX18uCiAgCkRpZmVyZW5jaWFyIGRlIG9yZGVuICRrJCBjb25zaXN0ZSBlbiByZXN0YXIgYSBsYSBvYnNlcnZhY2nDs24gZGUgdW4gcGVyaW9kbyBsYSBkZSAkayQgcGVyaW9kb3MgYW50ZXM6CiQkXG5hYmxhX2sgeV90ID0geV90IC0geV97dC1rfS4kJAoKIyMjIERpZmVyZW5jaWFjacOzbiByZWd1bGFyICgkaz0xJCkgey19CiAgClVuIGNhc28gY29uY3JldG8gZXMgbGEgX19kaWZlcmVuY2lhY2nDs24gcmVndWxhciBvIGRpZmVyZW5jaWFjacOzbiBkZSBvcmRlbiB1bm9fXywgcXVlIGNvbnNpc3RlIGVuIHJlc3RhciBhIGxhIG9ic2VydmFjacOzbiBkZSB1biBwZXJpb2RvIGxhIGRlbCBwZXJpb2RvIHByZWNlZGVudGU6CiQkXG5hYmxhIHlfdCA9IHlfdCAtIHlfe3QtMX0uJCQKClNpICRcbmFibGEgeV90JCBubyBmdWVyYSBlc3RhY2lvbmFyaWEsIHNlIGRpZmVyZW5jaWFyw61hIChyZWd1bGFybWVudGUpIHVuYSBzZWd1bmRhIHZleiBwYXJhIG9idGVuZXIgdW5hIGRvYmxlIGRpZmVyZW5jaWFjacOzbiBkZSBwcmltZXIgb3JkZW46CiQkXG5hYmxhXnsyfSB5X3QgPSBcbmFibGEoXG5hYmxhIHlfdCkgPSBcbmFibGEgeV90IC0gXG5hYmxhIHlfe3QtMX0gPSAoeV90IC0geV97dC0xfSkgLSAoeV97dC0xfSAtIHlfe3QtMn0pID0geV90IC0gMnlfe3QtMX0gKyB5X3t0LTJ9JCQKCkVuIGxhIHByw6FjdGljYSB1bmEgc29sYSBkaWZlcmVuY2lhY2nDs24gc3VlbGUgc2VyIHN1ZmljaWVudGUgcGFyYSBvYnRlbmVyIGxhIGVzdGFjaW9uYXJpZWRhZCBlbiBtZWRpYTsgZGlmZXJlbmNpYXIgZG9zIHZlY2VzIGVzIGV4Y2VwY2lvbmFsOyB5IGRpZmVyZW5jaWFyIHRyZXMgbyBtw6FzIHZlY2VzIG5vIHNlIGRhLgoKIyMjIERpZmVyZW5jaWFjacOzbiBlc3RhY2lvbmFsICgkaz1tJCkgey19CgpFeGlzdGUgbGEgX19kaWZlcmVuY2lhIGVzdGFjaW9uYWxfXywgcXVlIGNvbnNpc3RlIGVuIHJlc3RhciBhIGxhIG9ic2VydmFjacOzbiBkZSB1biBwZXJpb2RvIGxhIG9ic2VydmFjacOzbiBwcmVjZWRlbnRlIGRlIGxhIG1pc21hIGVzdGFjacOzbi4gU2kgZWwgb3JkZW4gZXN0YWNpb25hbCBlcyAkbSQsIGVudG9uY2VzIGxhIGRpZmVyZW5jaWEgZXN0YWNpb25hbCBkZSAkeV90JCBlcyAKJCRcbmFibGFfbSB5X3QgPSB5X3QgLSB5X3t0LW19LiQkClVuYSBzZXJpZSBubyBlc3RhY2lvbmFyaWEgZW4gbWVkaWEgcHVlZGUgcGFzYXIgYSBzZXJsbyB0cmFzIGRpZmVyZW5jaWFybGEgZXN0YWNpb25hbG1lbnRlLiBFcyBkZWNpciwgY3VhbHF1aWVyYSBkZSBsYXMgZG9zIGRpZmVyZW5jaWFjaW9uZXMgKHJlZ3VsYXIgbyBlc3RhY2lvbmFsKSBvIGFtYmFzIGEgbGEgdmV6IHNvbiBhbHRlcm5hdGl2YXMgcGFyYSBvYnRlbmVyIGxhIGVzdGFjaW9uYXJpZWRhZCBlbiBtZWRpYS4KCkFkZW3DoXMsIF9fbGEgZGlmZXJlbmNpYWNpw7NuIChyZWd1bGFyLCBlc3RhY2lvbmFsIG8gYW1iYXMpIHRhbWJpw6luIHBlcm1pdGUgYWxjYW56YXIgbGEgZXJnb2RpY2lkYWRfXy4KCkxhIGZpZ3VyYSAzIG11ZXN0cmEgdW4gZWplbXBsbyBkZSBkaWZlcmVuY2lhY2nDs24gcmVndWxhciB5L28gZXN0YWNpb25hbC4gRW4gZWwgcHJpbWVyIHBhbmVsIGFwYXJlY2UgbGEgc2VyaWUgb3JpZ2luYWwgTmFjaW1pZW50b3MgJHlfdCQ7IGVsIHNlZ3VuZG8gcGFuZWwgbXVlc3RyYSBsYSBzZXJpZSBkaWZlcmVuY2lhZGEgcmVndWxhcm1lbnRlICRcbmFibGEgeV90JDsgZW4gZWwgdGVyY2VyIHBhbmVsIGxhIHNlcmllIGRpZmVyZW5jaWFkYSBlc3RhY2lvbmFsbWVudGUgJFxuYWJsYV9tIHlfdCQ7IHkgZW4gZWwgY3VhcnRvIHBhbmVsIG11ZXN0cmEgbGEgc2VyaWUgZGlmZXJlbmNpYWRhIHJlZ3VsYXIgeSBlc3RhY2lvbmFsbWVudGUgJFxuYWJsYVxuYWJsYV9tIHlfdCQuCgpgYGB7ciwgZWNobz1GQUxTRSwgZmlnLmhlaWdodCA9IDV9CmNiaW5kKCJOYWNpZG9zIiA9IG5hY2ltaWVudG9zLAogICAgICAiRGlmLiByZWd1bGFyIiA9IGRpZmYobmFjaW1pZW50b3MpLAogICAgICAiRGlmLiBlc3RhY2lvbmFsIiA9IGRpZmYobmFjaW1pZW50b3MsIGxhZyA9IDEyKSwKICAgICAgIkRpZi4gcmVnLiB5IGVzdGEuIiA9IGRpZmYoZGlmZihuYWNpbWllbnRvcywgbGFnID0gMTIpKSkgJT4lCiAgYXV0b3Bsb3QoZmFjZXRzID0gVFJVRSwKICAgICAgICAgICB4bGFiID0gIiIsCiAgICAgICAgICAgeWxhYiA9ICIiLAogICAgICAgICAgIG1haW4gPSAiRmlndXJhIDMuIE5hY2ltaWVudG9zIikKYGBgCgpfwr9RdcOpIHRyYW5zZm9ybWFjacOzbiBwYXJhIG5hY2ltaWVudG9zIGNvbnNpZGVyYXMgcXVlIGdlbmVyYSB1bmEgc2VyaWUgZXN0YWNpb25hcmlhLCB0YW50byBlbiBtZWRpYSBjb21vIGVuIHZhcmlhbnphP18gU2llbXByZSBoYXkgdW4gY2llcnRvIGdyYWRvIGRlIHN1YmpldGl2aWRhZCBlbiBsYSBlbGVjY2nDs24gZGUgbGFzIGRpZmVyZW5jaWFzIHF1ZSBoYXkgcXVlIGFwbGljYXIgYSB1bmEgc2VyaWUuIEVuIGxhIGZpZ3VyYSAzIHBvZGVtb3MgY29uc2lkZXJhciBxdWUgbGEgZGlmZXJlbmNpYWNpw7NuIHJlZ3VsYXIgKHBhbmVsIDIpIGVzIHN1ZmljaWVudGUgcGFyYSBsb2dyYXIgbGEgZXN0YWNpb25hcmllZGFkIGVuIG1lZGlhIHkgZW4gdmFyaWFuemEgeSB0ZXJtaW5hciBlbCBwcm9jZXNvIGRlIGRpZmVyZW5jaWFjacOzbi4gUGVybyB0YW1iacOpbiBwb2RlbW9zIGNvbnNpZGVyYXIgcXVlIGxhIHNlcmllIGVzIGVzdGFjaW9uYXJpYSBlbiBtZWRpYSBwZXJvIG5vIGxvIHN1ZmljaWVudGUgZW4gdmFyaWFuemEsIHkgb3B0YXIgcG9yIGxhIGRvYmxlIGRpZmVyZW5jaWFjacOzbiwgcmVndWxhciB5IGVzdGFjaW9uYWwgKHBhbmVsIDQpLgoKIyMjIERpZmVyZW5jaWFjacOzbiBjb24gYFJgIHstfQoKYFJgIGRpc3BvbmUgZGUgbGEgZnVuY2nDs24gYGRpZmZgIHBhcmEgZGlmZXJlbmNpYXIgdW5hIHNlcmllOgoKKiBgZGlmZih4KWAgY2FsY3VsYSBsYSBkaWZlcmVuY2lhIHJlZ3VsYXIgbyBkZSBvcmRlbiAkMSQsICRcbmFibGEgeV90JAoqIGBkaWZmKHgsIGxhZyA9IGspYCBjYWxjdWxhIGxhIGRpZmVyZW5jaWEgZGUgb3JkZW4gJGskLCAkXG5hYmxhX2sgeV90JAoqIGBkaWZmKHgsIGxhZyA9IGssIGRpZmZlcmVuY2UgPSBkKWAgY2FsY3VsYSAkZCQgZGlmZXJlbmNpYXMgZGUgb3JkZW4gJGskLCAkXG5hYmxhX2teZCB5X3QkCgpTaSBuZWNlc2l0YXMgY2FsY3VsYXIgdW5hIGRpZmVyZW5jaWEgcmVndWxhciB5IG90cmEgZXN0YWNpb25hbCwgJFxuYWJsYVxuYWJsYV9tIHlfdCQsIGRlYmVzIHVzYXIgYGRpZmYoZGlmZih4LCBsYWcgPSBtKSlgLiBFbCBvcmRlbiBkZSBsYXMgZGlmZXJlbmNpYWNpb25lcyBubyBjYW1iaWEgZWwgcmVzdWx0YWRvLgoKQWRlbcOhcywgZW4gYGZvcmVjYXN0YCBlc3TDoSBkaXNwb25pYmxlIGxhcyBmdW5jaW9uZXMgYG5kaWZmc2AgeSBgbnNkaWZmc2AgcXVlIGVzdGltYW4gZWwgbsO6bWVybyBkZSBkaWZlcmVuY2lhcyByZWd1bGFyZXMgeSBlc3RhY2lvbmFsZXMsIHJlc3BlY3RpdmFtZW50ZSwgbmVjZXNhcmlhcyBwYXJhIHF1ZSB1bmEgc2VyaWUgc2VhIGVzdGFjaW9uYXJpYS4gUGFyYSBsYSBwcmltZXJhIHVzYSB1biBjb250cmFzdGUgZGUgcmHDrWNlcyB1bml0YXJpYXMgKHF1ZSBubyB2ZXJlbW9zIGVuIGVzdGUgY3Vyc28pIHkgcGFyYSBsYSBzZWd1bmRhIHVuIGNyaXRlcmlvIF9hZC1ob2NfLgoKCiMjIyBPcGVyYWRvciBSZXRhcmRvIHstfQoKRGVmaW5pbW9zIGVsIF9fb3BlcmFkb3IgcmV0YXJkb19fICRMJCBjb21vICRMeV90ID0geV97dC0xfSQsIGVzIGRlY2lyLCByZXRyYXNhIHVuIHBlcmlvZG8gbGEgc2VyaWUuIEVuIGluZ2zDqXMgc2UgZGVub21pbmEgX2xhZyBvcGVyYXRvcl8gKEwpIG8gX2JhY2t3YXJkIHNoaWZ0XyAoQikKCkFzw60sIHNlIHRpZW5lIHF1ZQokJExeayB5X3QgPSB5X3t0LWt9JCQKeSBwb3IgdGFudG8gcXVlCiQkClxiZWdpbnthbGlnbmVkfQogIFxuYWJsYSB5X3QgJiA9IHlfdCAtIHlfe3QtMX0gPSB5X3QgLSBMeV90ID0gKDEtTCl5X3QgXFwKICBcbmFibGFeZCB5X3QgJiA9ICgxLUwpXmQgeV90IFxcCiAgXG5hYmxhX20geV90ICYgPSAoMS1MXm0pIHlfdApcZW5ke2FsaWduZWR9CiQkCgpMYSBzaWd1aWVudGUgdGFibGEgbXVlc3RyYSB1biBzZW5jaWxsbyBlamVtcGxvIGRlbCBlZmVjdG8gZGVsIG9wZXJhZG9yIHJldGFyZG8gc29icmUgbGEgc2VyaWUgJHlfdCQKYGBge3IsIGVjaG89RkFMU0V9CmRhdGEuZnJhbWUoeSA9IDE6NywgbGFnMV95ID0gYyhOQSwgMTo2KSwgbGFnMl95ID0gYyhOQSxOQSwxOjUpICkKYGBgCgoKClwKCiMjIFRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2EKClNpIGxhIHNlcmllIG9yaWdpbmFsIG5vIGVzIGVzdGFjaW9uYXJpYSBlbiB2YXJpYW56YSBwb3JxdWUgbG9zIGRhdG9zIGNyZWNlbiBjb24gZWwgbml2ZWwgZGUgbGEgc2VyaWUsIGVzIHBvc2libGUgb2J0ZW5lciBsYSBlc3RhY2lvbmFyaWVkYWQgcG9yIG1lZGlvIGRlIHRyYW5zZm9ybWFjaW9uZXMgc2ltcGxlcy4KICAKTGEgdHJhbnNmb3JtYWNpw7NuIGxvZ2Fyw610bWljYSBkZSB1bmEgc2VyaWUgZXMgdW5hIGFsdGVybmF0aXZhLiBMYSBmaWd1cmEgNCBtdWVzdHJhIGxhIHNlcmllIE5hY2ltaWVudG9zIHkgc3UgbG9nYXJpdG1vLiBMYSB2YXJpYWJpbGlkYWQgZXN0YWNpb25hbCBjb24gbGEgdHJhbnNmb3JtYWNpw7NuIGxvZ2Fyw610bWljYSAocGFuZWwgaW5mZXJpb3IpIGVzIG1lbm9yIHF1ZSBlbiBsYSBzZXJpZSBvcmlnaW5hbCAocGFuZWwgc3VwZXJpb3IpLiAKCmBgYHtyLCBlY2hvPUZBTFNFLCBmaWcuaGVpZ2h0ID0gNX0KY2JpbmQoIk5hY2lkb3MiID0gbmFjaW1pZW50b3MsCiAgICAgICJsb2coTmFjaWRvcykiID0gbG9nKG5hY2ltaWVudG9zKSkgJT4lCiAgYXV0b3Bsb3QoZmFjZXRzID0gVFJVRSwKICAgICAgICAgICB4bGFiID0gIiIsCiAgICAgICAgICAgeWxhYiA9ICIiLAogICAgICAgICAgIG1haW4gPSAiRmlndXJhIDUuIFNlcmllIE5hY2ltaWVudG9zIHkgc3UgdHJhbnNmb3JtYWNpb25lcyBsb2dhcsOtdG1pY2EiKQpgYGAKCioqTm90YToqKiBsYSB0cmFuc2Zvcm1hY2nDs24gbG9nYXLDrXRtaWNhIGVzIHVuIGNhc28gY29uY3JldG8gZGUgb3RyYSBtw6FzIGdlbmVyYWwsIGxhIHRyYW5zZm9ybWFjacOzbiBkZSBCb3gtQ294IHF1ZSBubyB2ZXJlbW9zIGVuIGVzdGUgY3Vyc286CiQkCnpfdCA9IAogICAgXGJlZ2lue2Nhc2VzfQogICAgICAoeV90XntcbGFtYmRhfS0xKS9cbGFtYmRhICYgXCxcLFwsXGxhbWJkYSBcbmVxIDAgXFwKICAgICAgXGxvZyh5X3QpICYgXCxcLFwsIFxsYW1iZGEgPSAwIAogICAgXGVuZHtjYXNlc30KJCQKClNlIHB1ZWRlIGRlbW9zdHJhciBxdWUgJFxsaW1fe1xsYW1iZGEgXHJpZ2h0YXJyb3cgMH0gXDtcOyAoeV90XntcbGFtYmRhfS0xKS9cbGFtYmRhID0gbG9nKHlfdCkkLgoKXAoKIyMgRGlmZXJlbmNpYSwgTG9nYXJpdG1vIHkgVGFzYSBkZSB2YXJpYWNpw7NuCgpMYSB0cmFuc2Zvcm1hY2nDs24gJFxuYWJsYSB5X3QkIHNlIHB1ZWRlIGludGVycHJldGFyIGNvbW8gdmFyaWFjaW9uZXMgZW4gbml2ZWwsIHBlcm8gJFxuYWJsYV4yIHlfdCQgbm8gdGllbmUgbmluZ3VuYSBpbnRlcnByZXRhY2nDs24uIF9fTm8gY29udmllbmUgcGVyZGVyIGRlIHZpc3RhIGxhIGludGVycHJldGFiaWxpZGFkIGRlIGxhcyBvYnNlcnZhY2lvbmVzX18uCgpDdWFuZG8gdW5hIHNlcmllIHRpZW5lIHF1ZSBzZXIgZGlmZXJlbmNpYWRhIGRvcyB2ZWNlcyBwYXJhIGNvbnNlZ3VpciBzdSBlc3RhY2lvbmFyaWVkYWQsIHZhbGUgbGEgcGVuYSBwcm9iYXIgdW5hIHRyYW5zZm9ybWFjacOzbiBhbHRlcm5hdGl2YSBxdWUgc2VhIGludGVycHJldGFibGU6ICRcbmFibGEgXGxvZyh5X3QpJCBvICRcbmFibGFfbSBcbG9nKHlfdCkkLgoKUG9yIHVuIGxhZG8sCiAgJCRcbmFibGEgXGxvZyh5X3QpID0gXGxvZyh5X3QpIC0gXGxvZyh5X3t0LTF9KSA9IFxsb2dcYmlnKFxmcmFje3lfdH17eV97dC0xfX0gXGJpZykKICBcYXBwcm94IFxmcmFje3lfdH17eV97dC0xfX0gLSAxID0gXGZyYWN7eV90IC0geV97dC0xfX17eV97dC0xfX0gPVRWIHlfdC4kJAoKUG9yIGVqZW1wbG8sIHBhcmEgdW5hIHNlcmllIG1lbnN1YWwgX2xhIGRpZmVyZW5jaWEgcmVndWxhciBkZWwgbG9nYXJpdG1vIChuYXR1cmFsKSBlcyBsYSBUYXNhIGRlIFZhcmlhY2nDs24gTWVuc3VhbCBkZSBsYSBzZXJpZV8gJChcbmFibGEgXGxvZyh5X3QpPVRWTSB5X3QpJCwgcXVlIHRpZW5lIHVuYSBjbGFyYSBpbnRlcnByZXRhY2nDs24gY29tbyB2YXJpYWNpw7NuIHBvcmNlbnR1YWwuCgpQb3Igb3RybyBsYWRvLCAKJCRcbmFibGFfbSBcbG9nKHlfdCkgXGFwcHJveCBcZnJhY3t5X3QgLSB5X3t0LW19fXt5X3t0LW19fSA9VFZfbSB5X3QuJCQKCkVzIGRlY2lyLCBwYXJhIHVuYSBzZXJpZSBtZW5zdWFsIF9sYSBkaWZlcmVuY2lhIGVzdGFjaW9uYWwgZGVsIGxvZ2FyaXRtbyBlcyBsYSBUYXNhIGRlIFZhcmlhY2nDs24gQW51YWwgZGUgbGEgc2VyaWVfICQoXG5hYmxhX3sxMn0gXGxvZyh5X3QpPVRWQSB5X3QpJC4KClwKXAoKIyBGdW5jacOzbiBkZSBhdXRvY29ycmVsYWNpw7NuCgpTaSBsYSBzZXJpZSBlcyBlc3RhY2lvbmFyaWEgeSBlcmfDs2RpY2EsIGVsIHZhbG9yIG1lZGlvIGRlIGxhIHNlcmllIGVzIGNvbnN0YW50ZSB5LCBwb3IgdGFudG8sIG5vIGluZm9ybWF0aXZvLiAqKlNvbiBsYXMgY292YXJpYW56YXMgbG9zIHF1ZSBjYXJhY3Rlcml6YW4gZWwgcHJvY2VzbyBlc3RvY8Ohc3RpY28qKi4KClJlY29yZGVtb3MgcXVlICRcZ2FtbWFfaz1Db3YoeV90LHlfe3Qta30pJCBlcyBsYSBhdXRvY292YXJpYW56YSBkZSBvcmRlbiBrLiBQb3IgdGFudG8gJFxnYW1tYV8wJCBlcyBsYSB2YXJpYW56YSBkZSBsYSBzZXJpZSAkeV90JC4gU2VhICRccmhvX2skIGxhIGF1dG9jb3JyZWxhY2nDs24gc2Ugb3JkZW4gJGskLiBTZSBwdWVkZSB2ZXJpZmljYXIgcXVlOgokJFxyaG9fayA9IGNvcih5X3QsIHlfe3Qta30pID1cZnJhY3tcZ2FtbWFfa317XGdhbW1hXzB9LiQkCgoqICRccmhvXzEkIG1pZGUgbGEgaW5mb3JtYWNpw7NuIHF1ZSBzZSB0cmFuc21pdGUgZGUgdW4gcGVyaW9kbyBhbCBzaWd1aWVudGUgcGVyaW9kby4KKiAkXHJob19rJCBtaWRlIGxhIGluZm9ybWFjacOzbiBxdWUgc2UgdHJhbnNtaXRlIGsgcGVyaW9kb3MgaGFjaWEgYWRlbGFudGUuCgpMYXMgYXV0b2NvcnJlbGFjaW9uZXMgY2FyYWN0ZXJpemFuIGVsIHByb2Nlc28gZXN0b2PDoXN0aWNvLCB5IF9fbGEgZnVuY2nDs24gZGUgYXV0b2NvcnJlbGFjacOzbiBvIGNvcnJlbG9ncmFtYSAgKEZBQywgbyBBQ0YgZW4gaW5nbMOpcykgZXMgZWwgZ3LDoWZpY28gZGUgJHJfayQgY29udHJhICRrJF9fLCBkb25kZSAkcl9rJCBlcyBsYSBlc3RpbWFjacOzbiBkZSAkXHJob19rJCBvYnRlbmlkYSBjb24gbGFzIG9ic2VydmFjaW9uZXMuCgpMYSBmaWd1cmEgNiBtdWVzdHJhIGxhIEZBQyBwYXJhIGxhIHNlcmllIE5hY2ltaWVudG9zIHkgYWxndW5hcyBkZSBzdXMgdHJhbnNmb3JtYWNpb25lcy4gT2JzZXJ2YSBlbCBkaWZlcmVudGUgdXNvIGRlbCBhcmd1bWVudG8gYGxhZ2A6IGVuIGxhIGZ1bmNpw7NuIGBkaWZmYCBpbmRpY2EgZWwgb3JkZW4gZGUgbGEgZGlmZXJlbmNpYWNpw7NuLCB5IGVuIGxhIGZ1bmNpw7NuIGBnZ0FjZmAgaW5kaWNhIGVsIG9yZGVuIG3DoXhpbW8gZGUgbGEgYXV0b2NvcnJlbGFjacOzbi4gTGEgcHJpbWVyYSBjb2x1bW5hIG11ZXN0cmEgbGEgRkFDIHBhcmEgTmFjaW1pZW50b3MgeSB2YXJpYXMgZGlmZXJlbmNpYWNpb25lcywgbWllbnRyYXMgcXVlIGxhIHNlZ3VuZGEgY29sdW1uYSBtdWVzdHJhIGxhIEZBQyBwYXJhIGVsIGxvZ2FyaXRtbyBkZSBsb3MgbmFjaW1pZW50b3MgeSBzdXMgZGlmZXJlbmNpYWNpb25lcy4gU2UgcHVlZGUgb2JzZXJ2YXIgcXVlOgoKKiBMYSBGQUMgZGUgdW5hIHNlcmllIHkgZGUgc3UgdHJhbnNmb3JtYWNpw7NuIGxvZ2Fyw610bWljYSBzb24gbXV5IHNpbWlsYXJlcy4KKiBFbiBsb3MgcGFuZWxlcyBkZSBsYSBwcmltZXJhIHkgdGVyY2VyYSBmaWxhIGxhcyBhdXRvY29ycmVsYWNpb25lcyBkZWNyZWNlbiBtdXkgbGVudGFtZW50ZSwgaW5kaWNhbmRvIHF1ZSBsYSBzZXJpZSBhbmFsaXphZGEgbm8gZXMgZXN0YWNpb25hcmlhIG5pIGVyZ8OzZGljYS4gCiogRW4gbG9zIHBhbmVsZXMgZGUgbGEgc2VndW5kYSBmaWxhIGxhcyBhdXRvY29ycmVsYWNpb25lcyBkZSBvcmRlbiBlc3RhY2lvbmFsICgxMiwgMjQsLi4uKSB0YW1iacOpbiBkZWNyZWNlbiBsZW50YW1lbnRlLCBpbmRpY2FuZG8gcXVlIGxhIHNlcmllIGFuYWxpemFkYSBubyBlcyBlcmfDs2RpY2EuIAoqIFNvbG8gbGEgZG9ibGUgZGlmZXJlbmNpYWNpw7NuIHJlZ3VsYXIgeSBlc3RhY2lvbmFsIGRlIGxhIHNlcmllIChvcmlnaW5hbCBvIHN1IGxvZ2FyaXRtbykgbXVlc3RyYW4gdW4gcsOhcGlkbyBkZXNjZW5zbyBlbiBsb3MgY29lZmljaWVudGUgZGUgYXV0b2NvcnJlbGFjacOzbiAocGFuZWxlcyBkZSBsYSDDumx0aW1hIGZpbGEpLCBpbmRpY2FuZG8gcXVlIGxhIHNlcmllIGFzw60gdHJhbnNmb3JtYWRhIGVzIGVzdGFjaW9uYXJpYSBlbiBtZWRpYSB5IGVyZ8OzZGljYS4KCmBgYHtyLCBldmFsID0gRkFMU0V9CmdnQWNmKG5hY2ltaWVudG9zLCBsYWcgPSA0OCkKZ2dBY2YobG9nKG5hY2ltaWVudG9zKSwgbGFnID0gNDgpCmdnQWNmKGRpZmYobmFjaW1pZW50b3MpLCBsYWcgPSA0OCkKZ2dBY2YoZGlmZihsb2cobmFjaW1pZW50b3MpKSwgbGFnID0gNDgpCmdnQWNmKGRpZmYobmFjaW1pZW50b3MsIGxhZyA9IDEyKSxsYWcgPSA0OCkKZ2dBY2YoZGlmZihsb2cobmFjaW1pZW50b3MpLCBsYWcgPSAxMiksIGxhZyA9IDQ4KQpnZ0FjZihkaWZmKGRpZmYobmFjaW1pZW50b3MsIGxhZz0xMikpLCBsYWcgPSA0OCkKZ2dBY2YoZGlmZihkaWZmKGxvZyhuYWNpbWllbnRvcyksIGxhZz0xMikpLCBsYWcgPSA0OCkKYGBgCgpgYGB7ciwgZWNobyA9IEZBTFNFLCBmaWcuaGVpZ2h0PSA4fQpncmlkLmFycmFuZ2UoCiAgZ2dBY2YobmFjaW1pZW50b3MsIGxhZyA9IDQ4LCBtYWluID0gIkZpZ3VyYSA2LiBGQUMgcGFyYSBOYWNpbWllbnRvcyIsIHhsYWIgPSAiIiwgeWxhYiA9IGV4cHJlc3Npb24oeVt0XSkpLAogIGdnQWNmKGxvZyhuYWNpbWllbnRvcyksIGxhZyA9IDQ4LCBtYWluID0gIiIsIHhsYWIgPSAiIiwgeWxhYiA9IGV4cHJlc3Npb24oImxvZygiKnlbdF0qIikiKSksCiAgZ2dBY2YoZGlmZihuYWNpbWllbnRvcyksIGxhZyA9IDQ4LCBtYWluID0gIiIsIHhsYWIgPSAiIiwgeWxhYiA9IGV4cHJlc3Npb24obmFibGEqeVt0XSkpLAogIGdnQWNmKGRpZmYobG9nKG5hY2ltaWVudG9zKSksIGxhZyA9IDQ4LCBtYWluID0gIiIsIHhsYWIgPSAiIiwgeWxhYiA9IGV4cHJlc3Npb24obmFibGF+ImxvZygiKnlbdF0qIikiKSksCiAgZ2dBY2YoZGlmZihuYWNpbWllbnRvcywgbGFnID0gMTIpLCBsYWcgPSA0OCwgbWFpbiA9ICIiLCB4bGFiID0gIiIsIHlsYWIgPSBleHByZXNzaW9uKG5hYmxhWzEyXSp5W3RdKSksCiAgZ2dBY2YoZGlmZihsb2cobmFjaW1pZW50b3MpLCBsYWcgPSAxMiksIGxhZyA9IDQ4LCBtYWluID0gIiIsIHhsYWIgPSAiIiwgeWxhYiA9IGV4cHJlc3Npb24obmFibGFbMTJdfiJsb2coIip5W3RdKiIpIikpLAogIGdnQWNmKGRpZmYoZGlmZihuYWNpbWllbnRvcyksIGxhZyA9IDEyKSwgbGFnID0gNDgsIG1haW4gPSAiIiwgeGxhYiA9ICIiLCB5bGFiID0gZXhwcmVzc2lvbihuYWJsYSpuYWJsYVsxMl0qeVt0XSkpLAogIGdnQWNmKGRpZmYoZGlmZihsb2cobmFjaW1pZW50b3MpKSwgbGFnID0gMTIpLCBsYWcgPSA0OCwgbWFpbiA9ICIiLCB4bGFiID0gIiIsIHlsYWIgPSBleHByZXNzaW9uKG5hYmxhKm5hYmxhWzEyXX4ibG9nKCIqeVt0XSoiKSIpKSwKICBucm93ID0gNAopCmBgYAoKVGFtYmnDqW4gcG9kZW1vcyBwZWRpciBgUmAgcXVlIG5vcyBzdWdpZXJhIGxvcyDDs3JkZW5lcyBkZSBkaWZlcmVuY2lhY2nDs24gY29uIGxhcyBmdW5jaW9uZXMgYG5kaWZmc2AgeSBgbnNkaWZmc2AuIApgYGB7cn0KbmRpZmZzKG5hY2ltaWVudG9zKQpuc2RpZmZzKG5hY2ltaWVudG9zKQpgYGAKClNpIHF1ZXJlbW9zIHZlciBsb3MgdmFsb3JlcyBudW3DqXJpY29zIGRlIGxhcyBhdXRvY29ycmVsYWNpb25lcyBkZWJlbW9zIGHDsWFkaXIgYSBsYSBmdW5jacOzbiBgZ2dBZmNgIGVsIGFyZ3VtZW50byBgcGxvdCA9IEZBTFNFYC4gUGFyYSBsYSBzZXJpZSBkb2JsZW1lbnRlIGRpZmVyZW5jaWFkYSB2ZW1vcyBxdWUgbGFzIHJlbGFjaW9uZXMgbcOhcyBlbGV2YWRhcyBzZSBkYW4gcGFyYSB1biByZXRhcmRvICgkcl97MX09LTAuMzk2JCkgeSBwYXJhIDEyIHJldGFyZG9zICgkcl97MTJ9PS0wLjI5OCQpLCBlbCBkYXRvIHF1ZSBtw6FzIHNlIHBhcmVjZSBhIGxvcyBuYWNpbWllbnRvcyBkZSB1biBtZXMgc29uIGxvcyBuYWNpbWllbnRvcyBkZWwgbWVzIHByZXZpbyB5IGxvcyBuYWNpbWllbnRvcyBkZWwgbWlzbW8gbWVzIGRlbCBhw7FvIHByZXZpby4KCmBgYHtyfQpnZ0FjZihkaWZmKGRpZmYobmFjaW1pZW50b3MpLCBsYWcgPSAxMiksIGxhZz0xMiwgcGxvdCA9IEZBTFNFKQpgYGAKCkxhcyBiYW5kYXMgYXp1bGVzIGRlIGxhIEZBQyBtdWVzdHJhbiBlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphIGFsIDk1JSAoSUM5NSkuIFNpICRccmhvX2sgPSAwJCwgbGEgZGlzdHJpYnVjacOzbiBkZWwgZXN0aW1hZG9yICRyX2skIHNlIGRpc3RyaWJ1eWUgYXByb3hpbWFkYW1lbnRlIGNvbW8gdW5hIG5vcm1hbCBkZSBtZWRpYSAkLTEvVCQgeSB2YXJpYW56YSAkMS9UJC4gTGFzIGzDrW5lYXMgcHVudGVhZGFzIGRlIGxhIEZBQyBlc3TDoW4gZGlidWphZGFzIGVuIGxhcyBwb3NpY2lvbmVzICRcZnJhY3stMX17VH0gXHBtIFxmcmFjezEuOTZ9e1xzcXJ0e1R9fSQuCiAKKiBTaSB1biAkcl9rJCBjYWUgZnVlcmEgZGVsIElDOTUgaGF5IGV2aWRlbmNpYSBwYXJhIHJlY2hhemFyIGxhIGhpcMOzdGVzaXMgbnVsYSBkZSBxdWUgJFxyaG9fayA9IDAkIGEgdW4gbml2ZWwgZGVsIDUlLiBSZWNvcmRlbW9zIHF1ZSBpbmNsdXNvIHNpIHRvZG9zIGxvcyAkXHJob19rJCBzb24gY2VybywgY2FiZSBlc3BlcmFyIHF1ZSB1biA1JSBkZSBzdXMgZXN0aW1hY2lvbmVzICRyX2skIGNhaWdhbiBmdWVyYSBkZWwgSUM5NS4KCiogTG9zICRccmhvX2skIG5vIHNvbiBpbmRlcGVuZGllbnRlcy4gU2kgdW5vIGNhZSBmdWVyYSBkZWwgSUM5NSwgZXMgbcOhcyBwcm9iYWJsZSBxdWUgbG9zIHZhbG9yZXMgdmVjaW5vcyBjYWlnYW4gdGFtYmnDqW4gZnVlcmEuCgpcClwKCiMgUHJvY2Vzb3MgQVJJTUEKCkFSSU1BIHN1cmdlIGRlIGNvbWJpbmFyIGxhcyBzaWdsYXMgZGUgdHJlcyBwcm9jZXNvcyBkaWZlcmVudGVzOiBfX0FSX18gZGUgQXV0b1JlZ3Jlc2l2ZSwgX19JX18gZGUgSW50ZWdyYXRlZCB5IF9fTUFfXyBkZSBNb3ZpbmcgQXZlcmFnZS4gVmVhbW9zIGNhZGEgdW5vIGRlIGVzdG9zIHRyZXMgY29uY2VwdG9zIHBvciBzZXBhcmFkbyB5IGx1ZWdvIHN1IGNvbWJpbmFjacOzbi4gCgpBIGxvIGxhcmdvIGRlIGxvIHF1ZSByZXN0YSBkZWwgdGVtYSBhc3VtaXJlbW9zIHF1ZToKCiogJFx7eV90XH1fe3Q9MX1eVCQgZXMgdW5hIHJlYWxpemFjacOzbiBkZSB1biBwcm9jZXNvIGVzdG9jw6FzdGljbyBkZXNjb25vY2lkby4KICAgIAoqIEVsIHByb2Nlc28gZXN0b2PDoXN0aWNvIGVzIF9fZXN0YWNpb25hcmlvIGVuIHNlbnRpZG8gYW1wbGlvX186CiQkRVt5X3RdICA9IFxtdSA8IFxpbmZ0eSBcO1w7XDsgXGZvcmFsbCB0LCQkCiQkQ292W3lfdCwgeV97dC1rfV0gID0gXGdhbW1hX2sgIFw7XDtcOyBcZm9yYWxsIGsuJCQKICAgICAKKiBFbCBwcm9jZXNvIGVzdG9jw6FzdGljbyBlcyBfX2VyZ8OzZGljb19fLCBvIHN1IGNvbmRpY2nDs24gc3VmaWNpZW50ZTogCiQkXGxpbV97ayBccmlnaHRhcnJvdyBcaW5mdHl9IFxnYW1tYV9rICA9IDAuJCQKClwKCiMjIFByb2Nlc29zIGF1dG9ycmVncmVzaXZvcyBBUihwKQoKIyMjIERlZmluaWNpw7NuIHstfQoKRWwgbW9kZWxvIGdlbmVyYWwgX19hdXRvcnJlZ3Jlc2l2byBkZSBvcmRlbiBwX18sICR5X3QgXHNpbSBBUihwKSQgdmllbmUgZGVmaW5pZG8gcG9yCiQkeV90PWMgKyBccGhpXzEgeV97dC0xfSArIFxwaGlfMiB5X3t0LTJ9ICsgLi4uICsgXHBoaV9wIHlfe3QtcH0gKyBcdmFyZXBzaWxvbl90LCQkClxub2luZGVudCBxdWUgdXNhbmRvIGVsIG9wZXJhZG9yIHJldGFyZG8gcXVlZGEKJCQoMSAtIFxwaGlfMSBMIC0gXHBoaV8yIExeMiAtIC4uLiAtIFxwaGlfcCBMXnApeV90ID0gYyArIFx2YXJlcHNpbG9uX3QkJAoKRW4gZXN0ZSB5IGVuIGN1YWxxdWllciBwcm9jZXNvIEFSSU1BLCBhbCBwb2xpbm9taW8gZW4gJEwkIHF1ZSBhY29tcGHDsWEgYSAkeV90JCBzZSBsZSBkZW5vbWluYSAqKnBvbGlub21pbyBhdXRvcmVncmVzaXZvKiouCgpTZSBzdWVsZSBhc3VtaXIgcXVlIGVsIGVycm9yIGRlbCBtb2RlbG8gJFx2YXJlcHNpbG9uX3QkIHZlcmlmaWNhIGxhcyBoaXDDs3Rlc2lzIGVzdMOhbmRhciBkZSBtZWRpYSBjZXJvLCBpbmNvcnJlbGFjacOzbiwgaG9tb2NlZGFzdGljaWRhZCBlIGlkw6ludGljYSBkaXN0cmlidWNpw7NuOiAkXHZhcmVwc2lsb25fdCBcc2ltIGlpZCgwLCBcc2lnbWFeMikkLiBFbiBlc3RlIGN1cnNvIG5vIHZhbW9zIGEgcHJlc3RhciBhdGVuY2nDs24gYSBlc3RlIGNvbmp1bnRvIGRlIGhpcMOzdGVzaXMgcG9ycXVlIG5vIGp1Z2Fyw6FuIG5pbmfDum4gcGFwZWwgZW4gbGEgZWxlY2Npw7NuIGRlbCBtb2RlbG8gw7NwdGltbyAtLWFxdWVsIGNvbiBtZWpvcmVzIHByZWRpY2Npb25lcy4KCgojIyMgRWplbXBsb3Mgey19CgoqICR5X3QgXHNpbSBBUigxKTogXDtcO3lfdCA9IGMgKyBccGhpXzEgeV97dC0xfSArIFx2YXJlcHNpbG9uX3QkIG8gJCgxIC0gXHBoaV8xIEwpeV90ID0gYyArIFx2YXJlcHNpbG9uX3QkCiogJHlfdCBcc2ltIEFSKDIpOiBcO1w7eV90ID0gYyArIFxwaGlfMSB5X3t0LTF9ICsgXHBoaV8yIHlfe3QtMn0gKyBcdmFyZXBzaWxvbl90JCBvICQoMSAtIFxwaGlfMSBMIC0gXHBoaV8yIExeMil5X3QgPSBjICsgXHZhcmVwc2lsb25fdCQKClwKCiMjIFByb2Nlc29zIGVuIG1lZGlhcyBtw7N2aWxlcyBNQShxKQoKIyMjIERlZmluaWNpw7NuIHstfQoKRWwgbW9kZWxvIGdlbmVyYWwgX19lbiBtZWRpYXMgbcOzdmlsZXMgZGUgb3JkZW4gcV9fLCAkeV90IFxzaW0gTUEocSkkIHZpZW5lIGRlZmluaWRvIHBvcgokJHlfdD1jICsgXHZhcmVwc2lsb25fdCArIFx0aGV0YV8xIFx2YXJlcHNpbG9uX3t0LTF9ICsgXHRoZXRhXzIgXHZhcmVwc2lsb25fe3QtMn0gKyAuLi4gKyBcdGhldGFfcSBcdmFyZXBzaWxvbl97dC1xfSwkJApcbm9pbmRlbnQgcXVlIHVzYW5kbyBlbCBvcGVyYWRvciByZXRhcmRvIHF1ZWRhCiQkeV90ID0gYyArICgxICsgXHRoZXRhXzEgTCArIFx0aGV0YV8yIExeMiArIC4uLiArIFx0aGV0YV9xIExecSkgXHZhcmVwc2lsb25fdCQkCgojIyMgRWplbXBsb3Mgey19CgoqICR5X3QgXHNpbSBNQSgxKTogXDtcO3lfdCA9IGMgKyBcdmFyZXBzaWxvbl90ICsgXHRoZXRhXzEgXHZhcmVwc2lsb25fe3QtMX0kIG8gJHlfdCA9IGMgKyAoMSArIFx0aGV0YV8xIEwpXHZhcmVwc2lsb25fdCQKKiAkeV90IFxzaW0gTUEoMik6IFw7XDt5X3Q9YyArIFx2YXJlcHNpbG9uX3QgKyBcdGhldGFfMSBcdmFyZXBzaWxvbl97dC0xfSArIFx0aGV0YV8yIFx2YXJlcHNpbG9uX3t0LTJ9JCBvICR5X3QgPSBjICsgKDEgKyBcdGhldGFfMSBMICsgXHRoZXRhXzIgTF4yKVx2YXJlcHNpbG9uX3QkCgpcCgojIyBQcm9jZXNvcyBBUk1BKHAscSkKCiMjIyBEZWZpbmljacOzbiB7LX0KCkVsIG1vZGVsbyBnZW5lcmFsICR5X3QgXHNpbSBBUk1BKHAscSkkIHZpZW5lIGRhZG8gcG9yCiQkeV90ID0gYyArIFxwaGlfMSB5X3t0LTF9ICsgXHBoaV8yIHlfe3QtMn0gKyAuLi4gKyBccGhpX3AgeV97dC1wfSAgKyAKICAgICAgICBcdGhldGFfMSBcdmFyZXBzaWxvbl97dC0xfSArIFx0aGV0YV8yIFx2YXJlcHNpbG9uX3t0LTJ9ICsgLi4uICsKICAgICAgICBcdGhldGFfcSBcdmFyZXBzaWxvbl97dC1xfSsgXHZhcmVwc2lsb25fdCwkJApcbm9pbmRlbnQgcXVlIHVzYW5kbyBlbCBvcGVyYWRvciByZXRhcmRvIHF1ZWRhCiQkKDEgLSBccGhpXzEgTCAtIC4uLiAtIFxwaGlfcCBMXnApeV90ID0gYyArICgxICsgXHRoZXRhXzEgTCArIC4uLiArIFx0aGV0YV9xIExecSkgXHZhcmVwc2lsb25fdC4kJAoKIyMjIEVqZW1wbG9zIHstfQoKKiAkeV90IFxzaW0gQVJNQSgxLCAxKTogXDtcO3lfdCA9IGMgICsgXHBoaV8xIHlfe3QtMX0gKyBcdGhldGFfMSBcdmFyZXBzaWxvbl97dC0xfSArIFx2YXJlcHNpbG9uX3t0fSQgbyAkKDEgLSBccGhpXzEgTCl5X3QgPSBjICsgKDEgKyBcdGhldGFfMSBMKVx2YXJlcHNpbG9uX3QkLgoqICR5X3QgXHNpbSBBUk1BKDAsIDApOiBcO1w7eV90ID0gYyArIFx2YXJlcHNpbG9uX3t0fSQuIFNpICRjID0gMCQsIGEgZXN0ZSBwcm9jZXNvIHNlIGxlIGRlbm9tbWluYSAqKnJ1aWRvIGJsYW5jbyoqLgoKXAoKIyMgUHJvY2VzbyBBUklNQShwLGQscSkKCl9fU2kgbGEgc2VyaWUgJHlfdCQgbm8gZXMgZXN0YWNpb25hcmlhIHBlcm8gdHJhcyBkaWZlcmVuY2lhcmxhICRkJCB2ZWNlcyBzZSBoYWNlIGVzdGFjaW9uYXJpYSwgZGlyZW1vcyBxdWUgbGEgc2VyaWUgZXMgaW50ZWdyYWRhIGRlIG9yZGVuICRkJF9fOiAkeV90IFxzaW0gSShkKSQuIFBvciB0YW50bywKCiogdW5hIHNlcmllIGVzdGFjaW9uYXJpYSBzZSBpbmRpY2Fyw6EgY29tbyAkeV90IFxzaW0gSSgwKSQKKiAkeV90IFxzaW0gSShkKSQgZXMgZXF1aXZhbGVudGUgYSAkXG5hYmxhXmQgeV90ID0gKDEgLSBMKV5kIHlfdCBcc2ltIEkoMCkkCgpVbmEgc2VyaWUgJHlfdCQgc2lndWUgdW4gcHJvY2VzbyBfXyRBUklNQShwLGQscSkkX18gc2k6CgoxLiAkeV90IFxzaW0gSShkKSQgKGhheSBxdWUgZGlmZXJlbmNpYXJsYSAkZCQgdmVjZXMgcGFyYSBoYWNlcmxhIGVzdGFjaW9uYXJpYSksIHkKMi4gJFxuYWJsYV5kIHlfdCBcc2ltIEFSTUEocCxxKSQuCiAgICAgIApFbnRvbmNlcywgcG9kZW1vcyBlc2NyaWJpcjogCiQkeV90IFxzaW0gIEFSSU1BKHAsZCxxKTogXDtcO1w7ICgxIC0gXHBoaV8xIEwgLSBcbGRvdHMgLSBccGhpX3AgTF5wKSgxLSBMKV5kIHlfdCA9IGMgKyAoMSArIFx0aGV0YV8xIEwgKyAuLi4gKyBcdGhldGFfcSBMXnEpIFx2YXJlcHNpbG9uX3QuJCQKCiMjIyBFamVtcGxvcyB7LX0KCiogJHlfdCBcc2ltIEFSSU1BKDEsIDEsIDEpOiBcO1w7KDEgLSBccGhpXzEgTCkoMS0gTCkgeV90ID0gYyArICgxICsgXHRoZXRhXzEgTCkgXHZhcmVwc2lsb25fdCQgbyAkeV90ID0gYyArIHlfe3QtMX0gKyBccGhpXzEoeV97dC0xfSAtIHlfe3QtMn0pICsgXHRoZXRhXzEgXHZhcmVwc2lsb25fe3QtMX0gKyBcdmFyZXBzaWxvbl90JC4KKiAkeV90IFxzaW0gQVJJTUEoMCwgMSwgMCk6IFw7XDsoMS0gTCkgeV90ID0gYyArIFx2YXJlcHNpbG9uX3QkIG8gJHlfdCA9IGMgKyB5X3t0LTF9ICsgXHZhcmVwc2lsb25fdCQuIFNpICRjPTAkLCB0ZW5lbW9zIHVuICoqcGFzZW8gYWxldG9yaW8qKjsgc2kgJGMgXG5lcSAwJCwgdGVuZW1vcyB1biAqKnBhc2VvIGFsZWF0b3JpbyBjb24gZGVyaXZhKiouCiAKXApcCgojIEFwcm94aW1hY2nDs24gZGUgQm94LUplbmtpbnMKCkxhIHNpZ3VpZW50ZSBmaWd1cmEgbXVlc3RyYSBlbCBmbHVqbyBkZSBwcm9jZXNvcyBhc29jaWFkbyBhIGxhIG1vZGVsaXphY2nDs24gcG9yIG1vZGVsb3MgQVJJTUEsIGNvbiBjdWF0cm8gZ3JhbmRlcyDDoXJlYXM6CgoqIF9fSWRlbnRpZmljYWNpw7NuX18sIHF1ZSByZXF1aWVyZSBwcmltZXJvIHRyYW5zZm9ybWFyIGxhIHNlcmllIHBhcmEgcXVlIHNlYSBlc3RhY2lvbmFyaWEgeSBlcmfDs2RpY2EsIHBhcmEgZGVzcHXDqXMgaWRlbnRpZmljYXIgbG9zIHZhbG9yZXMgZGUgcCB5IHEuCgogIExhIEZBQyB5IGxhIGZ1bmNpw7NuIGRlIGF1dG9jb3JyZWxhY2nDs24gcGFyY2lhbCAocXVlIG5vIGhlbW9zIHZpc3RvKSB0ZcOzcmljYXMgc29uIGRpZmVyZW50ZXMgZW4gY2FkYSB0aXBvIGRlIHByb2Nlc28uIElkZWFsbWVudGUsIHN1IGVzdGltYWNpw7NuIGEgcGFydGlyIGRlIGxhIHNlcmllIHRlbXBvcmFsIHBvZHLDrWEgc2VydmlyIGRlIGF5dWRhIGVuIGxhIGlkZW50aWZpY2FjacOzbiBkZWwgcHJvY2VzbyBlc3RvY8Ohc3RpY28uIEVuIGxhIHByw6FjdGljYSwgbGEgZnVuY2lvbmVzIGVzdGltYWRhcyBzb24gdGFuIGRpZmVyZW50ZXMgZGUgbGFzIHRlw7NyaWNhcyBxdWUgcmVzdWx0YW4gZGUgbXV5IHBvY2EgYXl1ZGEuIAogIAogIE5vc290cm9zIGhhcmVtb3MgdXNvIGRlIGFsZ3VuYXMgZnVuY2lvbmVzIGRlIF9hdXRvXyBpZGVudGlmaWNhY2nDs24gcXVlIG5vcyBheXVkYXJhbiBlbiBlc3RlIHB1bnRvLgogIAoqIF9fRXN0aW1hY2nDs25fXyBkZSBsb3MgcGFyw6FtZXRyb3MgZGVsIG1vZGVsbywgaW5jbHVpZGFzIGxhcyB2YXJpYWJsZXMgZGUgaW50ZXJ2ZW5jacOzbiB5IG9idGVuY2nDs24gZGVsIGVycm9yLiBEYWRvIHVuIHByb2Nlc28sIGVsIG3DqXRvZG8gdXN1YWwgZGUgZXN0aW1hY2nDs24gZGUgc3VzIHBhcsOhbWV0cm9zIGVzIHBvciBtw6F4aW1hIHZlcm9zaW1pbGl0dWQuCgoqIF9fVmFsaWRhY2nDs25fXyBkZSBsYXMgaGlww7N0ZXNpcyBzb2JyZSBlbCBtb2RlbG8uIAoKICBFbiB1biBjdXJzbyB0cmFkaWNpb25hbCBkZSBtb2RlbG9zIEFyaW1hIHN1cG9uZHLDrWEgdmFsaWRhciBsYSBoaXDDs3Rlc2lzIHNvYnJlIGVsIHJlc2lkdW8sIGNvbnRyYXN0ZXMgZGUgc2lnbmlmaWNhdGl2aWRhZCBkZSBsb3MgcGFyw6FtZXRyb3MgZXN0aW1hZG9zIHkgY29tcHJvYmFjacOzbiBkZSBxdWUgbm8gaGF5IG3DoXMgaW50ZXJ2ZW5jacOzbi4gCiAgCiAgRW4gbnVlc3RybyBjYXNvLCBxdWUgaGVtb3MgcmVkdWNpZG8gbGFzIGhpcMOzdGVzaXMgYSBzdSBtw61uaW1hIGV4cHJlc2nDs24sIHNpbXBsZW1lbnRlIGFuYWxpemFyZW1vcyBxdWUgbm8gZXMgbmVjZXNhcmlhIG3DoXMgaW50ZXJ2ZW5jacOzbiB5IHZlcmVtb3MgbGEgcGVydGluZW5jaWEgZGUgbG9zIHBhcsOhbWV0cm9zIGRlbCBtb2RlbG8gKGJpZW4gY29udHJhc3RhbmRvIHN1IHNpZ25pZmljYXRpdmlkYWQgbyBiaWVuIHBvciBhbGd1bmEgcmVnbGEgbcOhcyBzZW5jaWxsYSkuCiAgCiAgU2kgbGEgdmFsaWRhY2nDs24gbm8gc2UgcGFzYSwgcHVlZGUgc2VyIG5lY2VzYXJpbyB2b2x2ZXIgYWwgcHJvY2VzbyBpbmljaWFsIHkgcmVhbGl6YXIgdW5hIG51ZXZhIGlkZW50aWZpY2FjacOzbiBkZWwgbW9kZWxvLgogIAoqIF9fUHJlZGljY2nDs25fXyBlIGludGVycHJldGFjacOzbiBkZWwgbW9kZWxvIHbDoWxpZG8uIFNpIGxhcyBwcmVkaWNjaW9uZXMgc2UgYWxlamFuIGRlIGxvcyB2YWxvcmVzIHJlYWxlcyBtw6FzIGRlIGxvIGVzcGVyYWRvIG8gcHJlc2VudGFuIHNlc2dvLCBwdWVkZSBzZXIgbmVjZXNhcmlvIGlkZW50aWZpY2FyIHkgZXN0aW1hciB1biBudWV2byBtb2RlbG8uCgohW0Fwcm94aW1hY2nDs24gQm94LUplbmtpbnNdKC4vaW1hZ2VuZXMvQm94SmVua2lucy5wbmcpCgpcClwKCiMjIyBJZGVudGlmaWNhY2nDs24gYXV0b23DoXRpY2Egey19CgpFbCBwYXF1ZXRlIGBmb3JlY2FzdGAgZGlzcG9uZSBkZSBsYSBmdW5jacOzbiBgYXV0by5hcmltYSgpYCBxdWUgbG9jYWxpemEgZWwgbWVqb3IgbW9kZWxvIGJhc8OhbmRvc2UgZW4gZWwgQUlDIGNvcnJlZ2lkbyBwYXJhIHBlcXVlw7FhcyBtdWVzdHJhcyAoYEFJQ2NgKS4gTm8gaGF5IHF1ZSBmaWFyc2UgY2llZ2FtZW50ZSBkZSBsb3MgcmVzdWx0YWRvcyBkZSBlc3RhIGZ1bmNpw7NuLCBwZXJvIGF5dWRhIGVuIGxhIGlkZW50aWZpY2FjacOzbi4gQsOhc2ljYW1lbnRlIGVsIGFsZ29yaXRtbyBzZWd1aWRvIGVzIGVsIHNpZ3VpZW50ZToKCjEuIERldGVybWluYSBlbCBvcmRlbiBkZSBkaWZlcmVuY2lhY2nDs24gcmVndWxhciAkMCBcbGVxIGQgXGxlcSAyJCB1c2FuZG8gbGEgZnVuY2nDs24gYG5kaWZmc2AuIAoyLiBUcmFzIGRpZmVyZW5jaWFyIGxhIHNlcmllOgogICAgKiBzZSBlc3RpbWFuIHVuYSBzZXJpZSBkZSBtb2RlbG9zIGLDoXNpY29zIHByZWRldGVybWluYWRvcy4gCiAgICAqIHNlIHVzYSBlbCBjcml0ZXJpbyBBSUNjIHBhcmEgc2VsZWNjaW9uYXIgZWwgbWVqb3IgZGUgZXN0b3MgbW9kZWxvcy4gCiAgICAqIGEgcGFydGlyIGRlbCBtb2RlbG8gc2VsZWNjaW9uYWRvLCBzZSBoYWNlbiBwZXF1ZcOxYXMgdmFyaWFjaW9uZXMgbW9kaWZpY2FuZG8gZW4gdW5hIHVuaWRhZCBfcF8geSBfcV8geSBhw7FhZGllbmRvL3F1aXRhbmRvIGxhIGNvbnN0YW50ZSB5IHNlIHZ1ZWx2ZSBhIHNlbGVjY2lvbmFyIGVsIG1lam9yIGRlIGxvcyBudWV2b3MgbW9kZWxvcy4KMy4gU2UgcmVwaXRlIGVsIHBhc28gMiBoYXN0YSBxdWUgbm8gc2UgcHVlZGUgbWVqb3JhciBlbCBBSUNjLiAKCkN1YW5kbyB1c2Vtb3MgZXN0YSBmdW5jacOzbiwgZGViZW1vcyB0ZW5lciBjdWVudGEgcXVlOgoKKiBMYSBmdW5jacOzbiBgYXV0by5hcmltYWAgbm8gcGVybWl0ZSBjb250YW50ZSBzaSBsYSBzdW1hIGRlIGxhcyBkaWZlcmVuY2lhY2lvbmVzIGVzIDIgbyBzdXBlcmlvci4gCiogU2kgc2UgZGVzZWEgaGFjZXIgdW5hIGLDunNxdWVkYSBleGhhdXN0aXZhIGVudHJlIHRvZG9zIGxvcyBwb3NpYmxlcyBtb2RlbG9zIHNlIGRlYmUgdXNhciBlbCBhcmd1bWVudG8gYHN0ZXB3aXNlID0gRkFMU0VgLgoqIFNpIHNlIGRlc2VhIHF1ZSBlbCBjw6FsY3VsbyBkZSBBSUNjIHNlYSBleGFjdG8gKHBvciBkZWZlY3RvIHBhcmEgZ2FuYXIgdGllbXBvIGNhbGN1bGEgdW5hIGFwcm94aW1hY2nDs24pLCBzZSBkZWJlIHVzYXIgZWwgYXJndW1lbnRvIGBhcHByb3hpbWF0aW9uID0gRkFMU0VgLgoqIFNpIHNlIGRlc2VhIHZlciBwYXJhIHRvZG9zIGxvcyBtb2RlbG9zIGFuYWxpemFkb3MgZWwgdmFsb3IgZGUgQUlDYywgc2UgZGViZSBpbmNsdWlyIGVsIGFyZ3VtZW50byBgdHJhY2UgPSBUUlVFYC4KCkxhIGZ1bmNpw7NuIGBhdXRvLmFyaW1hYCB0aWVuZGUgYSBzb2JyZS1wYXJhbWV0cml6YXIgbG9zIG1vZGVsb3MgeSBlcyBtdXkgcmVjb21lbmRhYmxlIF9heXVkYXJsYV8gaW5kaWNhbmRvIGxhcyBkaWZlcmVuY2lhY2lvbmVzLCBsb3MgcG9zaWJsZXMgdmFsb3JlcyBleHRyZW1vcy4uLiAKClwKXAoKIyBFamVtcGxvcwoKXAoKIyMgVMOtdHVsb3MgZGUgbGlicm9zIHkgcGFuZmxldG9zCgpWYW1vcyBhIGFwbGljYXIgbGEgbWV0b2RvbG9nw61hIGRlIEJveC1KZW5raW5zIGEgbGEgc2VyaWUgTGlicm9zIChuw7ptZXJvIGRlIHTDrXR1bG9zIHB1YmxpY2Fkb3MgYW51YWxtZW50ZSBlbiBFc3Bhw7FhIGRlc2RlIDE5OTMgaGFzdGEgMjAxOCkuCgoKYGBge3J9CmxpYnJvcyA8LSByZWFkLmNzdjIoIi4vc2VyaWVzL2xpYnJvcy5jc3YiLCBoZWFkZXIgPSBUUlVFKQpsaWJyb3MgPC0gdHMobGlicm9zWywgMl0sIHN0YXJ0ID0gMTk5MywgZnJlcXVlbmN5ID0gMSkKCmF1dG9wbG90KGxpYnJvcywKICAgICAgICAgeGxhYiA9ICIiLCAKICAgICAgICAgeWxhYiA9ICIiLCAKICAgICAgICAgbWFpbiA9ICJGaWd1cmEgNy4gVMOtdHVsb3MgcHVibGljYWRvcyIpCmBgYAoKIyMjIFRyYW5zZm9ybWFjacOzbiBkZSBsYSBzZXJpZSB7LX0KCkVsIHByaW1lciBwYXNvIGVzIHRyYW5zZm9ybWFyIGxhIHNlcmllIG9yaWdpbmFsIHBhcmEgcXVlIHNlYSBlc3RhY2lvbmFyaWEuIExhIGZpZ3VyYSA4IG11ZXN0cmEgbGEgZ3LDoWZpY2EgdGVtcG9yYWwgeSBsYSBGQUMgcGFyYSBsYSBzZXJpZSBvcmlnaW5hbCB5IHN1IHByaW1lcmEgZGlmZXJlbmNpYS4gCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQphdXRvcGxvdChsaWJyb3MsIHhsYWIgPSAiIiwgeWxhYiA9ICIiLCBtYWluID0gIkxpYnJvcyIpCmF1dG9wbG90KGRpZmYobGlicm9zKSwgeGxhYiA9ICIiLCB5bGFiID0gIiIsIG1haW4gPSAiRGlmZXJlbmNpYSBsaWJyb3MiKQpnZ0FjZihsaWJyb3MsIHhsYWIgPSAiIiwgeWxhYiA9ICJGQUMiLCBtYWluID0gIiIpCmdnQWNmKGRpZmYobGlicm9zKSwgeGxhYiA9ICIiLCB5bGFiID0gIkZBQyIsIG1haW4gPSAiIikKYGBgCgpgYGB7ciwgZWNobyA9IEZBTFNFfQpncmlkLmFycmFuZ2UoCiAgYXV0b3Bsb3QobGlicm9zLCB4bGFiID0gIkxpYnJvcyIsIHlsYWIgPSAiIiwgbWFpbiA9ICJGaWd1cmEgOS4gVMOtdHVsb3MgcHVibGljYWRvcyIpLAogIGF1dG9wbG90KGRpZmYobGlicm9zKSwgeGxhYiA9ICJEaWZlcmVuY2lhIGxpYnJvcyIsIHlsYWIgPSAiIiwgbWFpbiA9ICIiKSwKICBnZ0FjZihsaWJyb3MsIHhsYWIgPSAiIiwgeWxhYiA9ICJGQUMiLCBtYWluID0gIiIpLAogIGdnQWNmKGRpZmYobGlicm9zKSwgeGxhYiA9ICIiLCB5bGFiID0gIkZBQyIsIG1haW4gPSAiIiksCiAgbnJvdyA9IDIKKQpgYGAKCkFkZW3DoXMsCmBgYHtyfQpuZGlmZnMobGlicm9zKQpgYGAKClBvZGVtb3MgY29jbHVpciBxdWUgbGEgcHJpbWVyYSBkaWZlcmVuY2lhIGRlIGxhIHNlcmllIExpYnJvcyBlcyBlc3RhY2lvbmFyaWEgeSBlcmfDs2RpY2EuIEVzIGRlY2lyLCAkZD0xJCBvICRsaWJyb3MgXHNpbSBJKDEpJC4KCiMjIyBJZGVudGlmaWNhY2nDs24gey19CgpUcmFzIGRpZmVyZW5jaWFyIGxhIHNlcmllLCB2YW1vcyBhIGlkZW50aWZpY2FyIGxvcyB2YWxvcmVzIGRlICRwJCB5ICRxJC4gRXN0ZSBlcyBlbCBwcm9jZXNvIG3DoXMgZGlmw61jaWwgeSBwYXJhIHNpbXBsaWZpY2FyIGxhcyBjb3NhcyB2YW1vcyBhIGF5dWRhcm5vcyBkZSBsYSBmdW5jacOzbiBgYXV0by5hcmltYWAuCgpgYGB7cn0KYXV0by5hcmltYShsaWJyb3MsIHRyYWNlID0gVFJVRSkKYGBgCgpPYnNlcnZhIGNvbW8gbGEgaWRlbnRpZmljYWNpw7NuIGF1dG9tw6F0aWNhIGRhIGNvbW8gbWVqb3IgbW9kZWxvICRsaWJyb3NfdCBcc2ltIEFSSU1BKDAsMSwwKSQgc2luIGRlcml2YSwgcG9yIHRhbnRvLCBydWlkbyBibGFuY28sICRwPXE9MCQ6CiQkbGlicm9zX3QgPSBsaWJyb3Nfe3QtMX0gKyBcdmFyZXBzaWxvbl90JCQKCiMjIyBFc3RpbWFjacOzbiB7LX0KCkF1bnF1ZSBleGlzdGUgbGEgZnVuY2nDs24gYGFyaW1hYCBkZSBgc3RhdHNgLCB2YW1vcyBhIHVzYXIgbGEgZnVuY2nDs24gYEFyaW1hYCBkZSBsYSBsaWJyZXLDrWEgYGZvcmVjYXN0YCBwYXJhIGVzdGltYXIgZWwgbW9kZWxvIGlkZW50aWZpY2FkbyBwb3Igc2VyIG3DoXMgdmVyc8OhdGlsLiBFbCBhcmd1bWVudG8gYG9yZGVyYCBpbmRpY2EgbG9zIHZhbG9yZXMgZGUgKHAsIGQgLCBxKSBjb21vIHVuIHZlY3RvciB5IGVsIGFyZ3VtZW50byBsw7NnaWNvIGBpbmNsdWRlLmNvbnN0YW50YCBpbmRpY2Egc2kgc2UgZGVzZWEgaW5jbHVpciBsYSBjb25zdGFudGUgJGMkIGVuIGVsIG1vZGVsby4gKE1pcmEgZW4gbGEgYXl1ZGEgZGUgbGEgZnVuY2nDs24gYEFyaW1hYCBsYSBkaWZlcmVuY2lhIGVudHJlIGxvcyBhcmd1bWVudG9zIGBpbmNsdWRlLm1lYW5gLCBgaW5jbHVkZS5kcmlmdGAgZSBgaW5jbHVkZS5jb25zdGFudGApLgoKYGBge3J9CmFyaW1hMDEwIDwtIEFyaW1hKGxpYnJvcywgCiAgICAgICAgICAgICAgICAgb3JkZXI9YygwLCAxLCAwKSwgCiAgICAgICAgICAgICAgICAgaW5jbHVkZS5jb25zdGFudCA9IEZBTFNFKQphcmltYTAxMApgYGAKCk51ZXN0cm8gbW9kZWxvIGVzdGltYWRvIGVzOiAkXHdpZGVoYXR7bGlicm9zfV90ID0gbGlicm9zX3t0LTF9JC4gTGEgbWVqb3IgcHJlZGljY2nDs24gcGFyYSB1biBhw7FvLCBlcyBsYSBvYnNlcnZhY2nDs24gZGVsIGHDsW8gYW50ZXJpb3IsIMKhZWwgbcOpdG9kbyBpbmdlbnVvIEkhCgojIyMgSW50ZXJ2ZW5jacOzbiB7LX0KClNlIGFuYWxpemEgc2kgcGFyYSBhbGfDum4gYcOxbyBzZSBvYnNlcnZhIHVuIGVycm9yIGF0w61waWNvICAocG9yIGVqZW1wbG8gMyB2ZWNlcyBzdXBlcmlvciBhbCBlcnJvciBlc3TDoW5kYXIpLiBMYSBmaWd1cmEgOSBtdWVzdHJhIHF1ZSBlbiBlc3RlIGNhc28gZW4gZG9zIHBlcmlvZG9zLCBhw7FvcyAyMDA4IHkgMjAxMywgZWwgcmVzaWR1byBzb2JyZXBhc2EgbG9zIGRvcyBlcnJvcmVzIGVzdMOhbmRhciBwZXJvIHF1ZWRhIGxlam9zIGRlIGxvcyB0cmVzIGVycm9yZXMgZXN0w6FuZGFyIGFzw60gcXVlIGFzdW1pcmVtb3MgcXVlIG5vIGhheSB2YWxvcmVzIGF0w61waWNvcy4KCmBgYHtyfQplcnJvciA8LSByZXNpZHVhbHMoYXJpbWEwMTApCnNkZXJyb3IgPC0gc2QoZXJyb3IpCgphdXRvcGxvdChlcnJvciwgc2VyaWVzPSJFcnJvciIsCiAgICAgICAgIGNvbG91ciA9ICJibGFjayIsCiAgICAgICAgIHhsYWIgPSAiIiwKICAgICAgICAgeWxhYiA9ICJFcnJvciIsCiAgICAgICAgIG1haW4gPSAiRmlndXJhIDkuIEVycm9yICsgSW50ZXJ2ZW5jacOzbiIpICsKICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSBjKC0zLCAtMiwgMiwgMykqc2RlcnJvciwgCiAgICAgICAgICAgICBjb2xvdXIgPSBjKCJyZWQiLCAiZ3JlZW4iLCAiZ3JlZW4iLCAicmVkIiksIAogICAgICAgICAgICAgbHR5ID0gMikgKyAKICBnZW9tX3BvaW50KCkgKwogIHNjYWxlX3hfY29udGludW91cyhicmVha3M9IHNlcSgxOTkzLCAyMDE5LCAyKSkgCmBgYAoKIyMjIE1lZGlkYXMgZGUgZXJyb3Igey19CgpFbCBlcnJvciBtZWRpbyBlcyBgciByb3VuZChhY2N1cmFjeShhcmltYTAxMClbMl0sMClgIHTDrXR1bG9zIChSTVNFKSB5IGVsIGVycm9yIHBvcmNlbnR1YWwgbWVkaW8gKE1BUEUpIGVzIGByIHJvdW5kKGFjY3VyYWN5KGFyaW1hMDEwKVs1XSwyKWAlLgoKYGBge3IsIGV2YWw9RkFMU0V9CmFjY3VyYWN5KGFyaW1hMDEwKQpgYGAKCmBgYHtyLGVjaG89RkFMU0V9CnJvdW5kKGFjY3VyYWN5KGFyaW1hMDEwKSwyKQpgYGAKCiMjIyBQcmVkaWNjacOzbiB7LX0KClVuYSB2ZXogdmFsaWRhZG8gZWwgbW9kZWxvIHBvZGVtb3MgcGFzYXIgYSByZWFsaXphciBfX3ByZWRpY2Npb25lc19fLCBlbiBlc3RlIGNhc28gYSA1IGHDsW9zIHZpc3RhLgoKYGBge3J9CnBhcmltYTAxMCA8LSBmb3JlY2FzdChhcmltYTAxMCwgaCA9IDUsIGxldmVsID0gOTUpCnBhcmltYTAxMApgYGAKCmBgYHtyfQphdXRvcGxvdChwYXJpbWEwMTAsIAogICAgICAgICB4bGFiID0gIiIsIAogICAgICAgICB5bGFiID0gIlTDrXR1bG9zIiwKICAgICAgICAgbWFpbiA9ICJGaWd1cmUgMTAuIExpYnJvcyAoMTk5My0yMDE4KSB5IHByZWRpY2Npw7NuICgyMDE5LTIwMjMpIikgKwogIHNjYWxlX3hfY29udGludW91cyhicmVha3M9IHNlcSgxOTkzLCAyMDIzLCAyKSkgCmBgYAoKCkxhIGZpZ3VyYSAxMCBtdWVzdHJhIGxhIHNlcmllLCBsYSBwcmV2aXNpw7NuIHkgZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBhbCA5NSUuIExhIHByZWRpY2Npw7NuIGVzIGNvbnN0YW50ZSBlIGlndWFsIGFsIMO6bHRpbW8gZGF0by4gRW4gbGFzIHNlcmllcyBkaWZlcmVuY2lhZGFzIGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZGUgbGFzIHByZWRpY2Npb25lcyBjcmVjZSBtdXkgcsOhcGlkYW1lbnRlIHBvcnF1ZSBsb3MgZXJyb3JlcyBzZSB2YW4gYWN1bXVsYW5kbyBzaW4gbmluZ8O6biB0aXBvIGRlIGFtb3J0aWd1YW1pZW50by4gCgoKXAoKIyMgQWZvcm8gZGUgdmVow61jdWxvcwoKVmFtb3MgYSBhcGxpY2FyIGRlIG51ZXZvIGxhIG1ldG9kb2xvZ8OtYSBkZSBCb3gtSmVua2lucyBhIGxhIHNlcmllIF9fYWZvcm8gZGUgdmVow61jdWxvc19fIHBvciBPcm9wZXNhLCBjYXJyZXRlcmEgTi0zNDAsIGttLiA5OTYsNDggKGZ1ZW50ZSBNaW5pc3RlcmlvIGRlIEZvbWVudG8pLiBMYSBzZXJpZSBlcyBhbnVhbCBkZSAxOTYwIGEgMjAxOCAoNTkgZGF0b3MpLgogICAgCmBgYHtyfQphZm9ybyA8LSByZWFkLmNzdjIoIi4vc2VyaWVzL2Fmb3JvX29yb3Blc2EuY3N2IiwgaGVhZGVyID0gVFJVRSkKYWZvcm8gPC0gdHMoYWZvcm8sIHN0YXJ0ID0gMTk2MCwgZnJlcSA9IDEpCgphdXRvcGxvdChhZm9ybywgCiAgICAgICAgIHhsYWIgPSAiIiwgCiAgICAgICAgIHlsYWIgPSAiVmVow61jdWxvcyAoMDAwKSIsCiAgICAgICAgIG1haW4gPSAiRmlndXJhIDExLiBBZm9ybyBkZSB2ZWjDrWN1bG9zIGVuIE4tMzQwLCBPcm9wZXNhIikKYGBgCgpFbiBlc3RlIGVqZW1wbG8gdmFtb3MgYSB0cmFiYWphciBjb24gZWwgbG9nYXJpdG1vIGRlIGxhIHNlcmllIHBhcmEgcG9kZXIgdmVyIGFsZ3Vub3MgZGV0YWxsZXMgcmVsYWNpb25hZG9zIGNvbiBsYSBpbnRlcnByZXRhY2nDs24gZGVsIG1vZGVsbyB5IGxhIHByZWRpY2Npw7NuLiBBZGVtw6FzLCBpbmNsdWlyZW1vcywgcG9yIHByaW1lcmEgdmV6LCBpbnRlcnZlbmNpw7NuIHkgdmVyZW1vcyBjb21vIF9fbGEgcHJlc2VuY2lhIGRlIHZhbG9yZXMgYXTDrXBpY29zIHB1ZWRlIGRpc3RvcnNpb25hciBlbCBwcm9jZXNvIGRlIGlkZW50aWZpY2FjacOzbl9fLiBQb3IgZWxsbywgZXMgY29udmVuaWVudGUgcmVhbGl6YXIgZW4gcGFyYWxlbG8gYW1iYXMgYWN0aXZpZGFkZXMsIGlkZW50aWZpY2FyIGVsIHByb2Nlc28geSBkZXRlY3RhciB2YWxvcmVzIGF0w61waWNvcy4KICAgICAgCiMjIyBUcmFuc2Zvcm1hY2nDs24gZGUgbGEgc2VyaWUgey19CgpMYSBmaWd1cmEgMTIgbXVlc3RyYSBxdWUgbGEgc2VyaWUgQWZvcm8gKGxvZykgbm8gZXMgZXN0YWNpb25hcmlhLiBBc8OtLCBlbCBwcmltZXIgcGFzbyBlcyB0cmFuc2Zvcm1hciBsYSBzZXJpZSBvcmlnaW5hbCBwYXJhIHF1ZSBsbyBzZWEuIExhIGZpZ3VyYSAxMiBubyBkZWphIGNsYXJvIHNpIGxhIHByaW1lcmEgZGlmZXJlbmNpYSBlcyBzdWZpY2llbnRlIHBhcmEgYWxjYW56YXIgbGEgZXN0YWNpb25hcmllZGFkIChncsOhZmljb3MgZGUgbGEgc2VndW5kYSBjb2x1bW5hKS4gU2luIGVtYmFyZ28sIHRyYXMgZGlmZXJlbmNpYXIgZG9zIHZlY2VzIGxhIHNlcmllIGVzIGNsYXJhbWVudGUgZXN0YWNpb25hcmlhLiBQb3IgdGFudG8gc2Ugb3B0YSBwb3IgY29uc2lkZXJhciAkZD0yJCBvICRsb2coYWZvcm9fdCkgXHNpbSBJKDIpJC4gTGEgZnVuY2nDs24gYG5kaWZmc2AgdGFtYmnDqW4gYWNvbnNlamEgbGEgZG9ibGUgZGlmZXJlbmNpYWNpw7NuLgoKYGBge3IsIGV2YWwgPSBGQUxTRX0KYXV0b3Bsb3QobG9nKGFmb3JvKSwgCiAgICAgICAgIHhsYWIgPSAibG9nKEFmb3JvKSIsIHlsYWIgPSAiIiwgbWFpbiA9ICIiKQphdXRvcGxvdChkaWZmKGxvZyhhZm9ybykpLCAKICAgICAgICAgeGxhYiA9ICJVbmEgZGlmZXJlbmNpYSBkZSBsb2coQWZvcm8pIiwgeWxhYiA9ICIiLCBtYWluID0gIiIpCmF1dG9wbG90KGRpZmYobG9nKGFmb3JvKSwgZGlmZmVyZW5jZXMgPSAyKSwgCiAgICAgICAgIHhsYWIgPSAiRG9zIGRpZmVyZW5jaWFzIGRlIGxvZyhBZm9ybykiLCB5bGFiID0gIiIsIG1haW4gPSAiIikKZ2dBY2YobG9nKGFmb3JvKSwgeGxhYiA9ICIiLCB5bGFiID0gIkZBQyIsIG1haW4gPSAiIikKZ2dBY2YoZGlmZihsb2coYWZvcm8pKSwgeGxhYiA9ICIiLCB5bGFiID0gIkZBQyIsIG1haW4gPSAiIikKZ2dBY2YoZGlmZihsb2coYWZvcm8pLCBkaWZmZXJlbmNlcyA9IDIpLCB4bGFiID0gIiIsIHlsYWIgPSAiRkFDIiwgbWFpbiA9ICIiKQpgYGAKCmBgYHtyLCBlY2hvID0gRkFMU0V9CmdyaWQuYXJyYW5nZSgKICBhdXRvcGxvdChsb2coYWZvcm8pLCB4bGFiID0gImxvZyhBZm9ybykiLCB5bGFiID0gIiIsIG1haW4gPSAiRmlndXJhIDEyLiBBZm9ybyBkZSB2ZWjDrWN1bG9zIiksCiAgYXV0b3Bsb3QoZGlmZihsb2coYWZvcm8pKSwgeGxhYiA9ICJVbmEgZGlmZXJlbmNpYSBkZSBsb2coQWZvcm8pIiwgeWxhYiA9ICIiLCBtYWluID0gIiIpLAogIGF1dG9wbG90KGRpZmYobG9nKGFmb3JvKSwgZGlmZmVyZW5jZXMgPSAyKSwgeGxhYiA9ICJEb3MgZGlmZXJlbmNpYXMgZGUgbG9nKEFmb3JvKSIsIHlsYWIgPSAiIiwgbWFpbiA9ICIiKSwKICBnZ0FjZihsb2coYWZvcm8pLCB4bGFiID0gIiIsIHlsYWIgPSAiRkFDIiwgbWFpbiA9ICIiKSwKICBnZ0FjZihkaWZmKGxvZyhhZm9ybykpLCB4bGFiID0gIiIsIHlsYWIgPSAiRkFDIiwgbWFpbiA9ICIiKSwKICBnZ0FjZihkaWZmKGxvZyhhZm9ybyksIGRpZmZlcmVuY2VzID0gMiksIHhsYWIgPSAiIiwgeWxhYiA9ICJGQUMiLCBtYWluID0gIiIpLAogIG5yb3cgPSAyCikKYGBgCgpgYGB7cn0KbmRpZmZzKGxvZyhhZm9ybykpCmBgYAoKCiMjIyBJZGVudGlmaWNhY2nDs24gey19CgpWZWFtb3MgYSBpZGVudGlmaWNhciBsb3MgdmFsb3JlcyBkZSAkcCQgeSAkcSQgYSBwYXJ0aXIgZGUgYGF1dG8uYXJpbWFgLiBMYSBmdW5jacOzbiBzdWdpZXJlIHVuIHByb2Nlc28gTUEoMikuIFBhcmVjZSBxdWUgbG9zIGRvcyBjb2VmaWNpZW50ZXMgZXN0aW1hZG9zIHNvbiBzaWduaWZpY2F0aXZvcyAtLWxhIGVzdGltYWNpw7NuIGVzIG1heW9yIHF1ZSBkb3MgdmVjZXMgc3UgZXJyb3IgZXN0w6FuZGFyIChzdGFuZGFyZCBlcnJvciwgcy5lKS4KCmBgYHtyfSAKYXV0by5hcmltYShhZm9ybywgCiAgICAgICAgICAgbGFtYmRhID0gMCkKYGBgCgpWYW1vcyBhIHZlciBsYSBncsOhZmljYSBkZSBsb3MgcmVzaWR1b3MgZGVsIG1vZGVsbyBNQSgyKSwgdmFtb3MgYSBpZGVudGlmaWNhciBsb3MgdmFsb3JlcyBleHRyZW1vcyAoaW50ZXJ2ZW5jacOzbikgeSB2YW1vcyBhIHNvbGljaXRhciB1bmEgdmV6IG3DoXMgbGEgYXV0by1pZGVudGlmaWNhY2nDs24gcGVybyBpbmNsdXllbmRvIGxhcyB2YXJpYWJsZXMgZmljdGljaWFzIGFzb2NpYWRhcyBhIGNhZGEgdmFsb3IgZXh0cmVtby4KCgpgYGB7cn0KYXJpbWEwMjIgPC0gQXJpbWEoYWZvcm8sIAogICAgICAgICAgICAgICAgICBvcmRlciA9IGMoMCwgMiwgMiksCiAgICAgICAgICAgICAgICAgIGxhbWJkYSA9IDApCgplcnJvciA8LSByZXNpZHVhbHMoYXJpbWEwMjIpCnNkZXJyb3IgPC0gc2QoZXJyb3IpCgphdXRvcGxvdChlcnJvciwgc2VyaWVzPSJFcnJvciIsCiAgICAgICAgIGNvbG91ciA9ICJibGFjayIsCiAgICAgICAgIHhsYWIgPSAiIiwKICAgICAgICAgeWxhYiA9ICJFcnJvciIsCiAgICAgICAgIG1haW4gPSAiRmlndXJhIDEzLiBFcnJvciArIEludGVydmVuY2nDs24iKSArCiAgZ2VvbV9obGluZSh5aW50ZXJjZXB0ID0gYygtMywgLTIsIDIsIDMpKnNkZXJyb3IsIAogICAgICAgICAgICAgY29sb3VyID0gYygicmVkIiwgImdyZWVuIiwgImdyZWVuIiwgInJlZCIpLCAKICAgICAgICAgICAgIGx0eSA9IDIpICsgCiAgZ2VvbV9wb2ludCgpICsKICBzY2FsZV94X2NvbnRpbnVvdXMoYnJlYWtzPSBzZXEoMTk2MCwgMjAxNCwgNCkpIApgYGAKClNlIGlkZW50aWZpY2FuIGRvcyBwb3NpYmxlcyB2YWxvcmVzIGV4dHJlbW9zIGVuIGxvcyBhw7FvcyAxOTc5IHkgMTk4MS4gQWRlbcOhcywgdmFtb3MgYSBpbmNsdWlyIG90cmFzIGRvcyBpbnRlcnZlbmNpb25lcyBwYXJhIGxvcyBhw7FvcyAxOTg0IHkgMjAxMSBwb3JxdWUgc2kgbm8gc2Vyw61hbiBuZWNlc2FyaWFzIG3DoXMgYWRlbGFudGUuIEVudG9uY2VzLCBjcmVhbW9zIHVuYSB2YXJpYWJsZSBmaWN0aWNpYSBhc29jaWFkYSBhIGNhZGEgYcOxbyBkMTk3OSwgZDE5ODEsIGQxOTg0IHkgZDIwMTEsIHkgbGFzIGluY2x1aW1vcyBlbiBsYSBhdXRvLWlkZW50aWZpY2FjacOzbi4KCmBgYHtyfQpkMTk3OSA8LSAxKih0aW1lKGVycm9yKSA9PSAxOTc5KQpkMTk4MSA8LSAxKih0aW1lKGVycm9yKSA9PSAxOTgxKQpkMTk4NCA8LSAxKih0aW1lKGVycm9yKSA9PSAxOTg0KQpkMjAxMSA8LSAxKih0aW1lKGVycm9yKSA9PSAyMDExKQoKYXV0by5hcmltYShhZm9ybywgCiAgICAgICAgICAgbGFtYmRhID0gMCwgCiAgICAgICAgICAgeHJlZyA9IGNiaW5kKGQxOTc5LCBkMTk4MSwgZDE5ODQsIGQyMDExKSkKYGBgCgpPYnNlcnZhIGNvbW8gbGEgaW5jbHVzacOzbiBkZSBpbnRlcnZlbmNpw7NuIG1vZGlmaWNhIGxhIGF1dG8taWRlbnRpZmljYWNpw7NuLCBxdWUgYWhvcmEgZXMgdW4gcHJvY2VzbyBBUklNQSgxLDIsMCkuIEFzdW1pbW9zIHF1ZSAkbG9nKGFmb3JvX3QpIFxzaW0gQVJJTUEoMSwyLDApJCBjb24gaW50ZXJ2ZW5jacOzbi4KCiMjIyBFc3RpbWFjacOzbiB7LX0KCmBgYHtyfQphcmltYTEyMCA8LSBBcmltYShhZm9ybywgCiAgICAgICAgICAgICAgICAgIG9yZGVyID0gYygxLCAyLCAwKSwgCiAgICAgICAgICAgICAgICAgIGxhbWJkYSA9IDAsICAKICAgICAgICAgICAgICAgICAgeHJlZyA9IGNiaW5kKGQxOTc5LCBkMTk4MSwgZDE5ODQsIGQyMDExKSkKYXJpbWExMjAKYGBgCgpMYSBpZGVudGlmaWNhY2nDs24gZGUgZXJyb3JlcyBhdMOtcGljb3MgLS1wYXJhIGxhIHBvc3RlcmlvciBpbmNsdXNpw7NuIGRlIHN1cyB2YXJpYWJsZXMgZGUgaW50ZXJ2ZW5jacOzbiBhc29jaWFkYXMtLSBoYSBzaWRvIHVuIHRhbnRvIGFyYml0cmFyaWE6IMK/ZXMgYXTDrXBpY28gZWwgZXJyb3IgcXVlIHN1cGVyYSBsYXMgMiBkZXN2aWFjaW9uZXMgdMOtcGljYXMsIGxhcyBkb3MgeSBtZWRpYSwgbGFzIHRyZXMgZGVzdmlhY2lvbmVzIHTDrXBpY2FzPwoKQSBmaW4gZGUgcG9uZXIgdW4gcG9jbyBkZSBfb2JqZXRpdmlkYWRfIGVuIGxhIGRlY2lzacOzbiwgcG9kZW1vcyB2ZXIgc2kgc3VzIGNvZWZpY2llbnRlcyBzb24gc2lnbmlmaWNhdGl2b3MgeSBkZWphciBzb2xvIGFxdWVsbGFzIHZhcmlhYmxlcyBkZSBpbnRlcnZlbmNpw7NuIHF1ZSBsbyBzZWFuLiBBdW5xdWUgc2kgbGEgc2VyaWUgZXMgc3VmaWNpZW50ZW1lbnRlIGxhcmdhLCB0YW1iacOpbiBwb2Ryw61hbW9zIHNhbHRhcm5vcyBlc3RlIHBhc28geSBkZWphciBsYXMgdmFyaWFibGVzIGRlIGludGVydmVuY2nDs24gcXVlIG1lam9yZW4gbGFzIHByZWRpY2Npb25lcyBleHRyYS1tdWVzdHJhbGVzIGRlbCBtb2RlbG8gbyBsYXMgcXVlIHJlY29qYW4gZWZlY3RvcyBjb24gdW5hIGdyYW4gZXZpZGVuY2lhLgoKTGEgcHJ1ZWJhIGRlIFdhbGQgcGVybWl0ZSBjb250cmFzdGFyIHNpIHVuIHN1YmNvbmp1bnRvIGRlIGNvZWZpY2llbnRlcyBlcyBzaWduaWZpY2F0aXZvIChzZSBwcmVjaXNhIGxhIGxpYnJlcsOtYSBgYW9kYCkuIEVzdGEgZnVuY2nDs24gcmVxdWllcmUgZGUgdHJlcyBhcmd1bWVudG9zOiBlbCB2ZWN0b3IgZGUgY29lZmljaWVudGVzIChgYmApLCBzdSBtYXRyaXogZGUgY292YXJpYW56YXMgKGBTaWdtYWApIHkgbGEgcG9zaWNpw7NuIGRlIGxvcyBjb2VmaWNpZW50ZXMgY3V5YSBzaWduaWZpY2F0aXZpZGFkIGNvbmp1bnRhIGRlc2VhbW9zIGNvbnRyYXN0YXIgKGBUZXJtc2ApLiBMb3MgZG9zIHByaW1lcm9zIGFyZ3VtZW50b3MgbG9zIHBvZGVtb3Mgb2J0ZW5lciBkZWwgb2JqZXRvIGBhcmltYTEyMGAgY29uIGxhcyBmdW5jaW9uZXMgYGNvZWZgIHkgYHZjb3ZgLiAKClBvciBlamVtcGxvLCBwYXJhIHZlciBsYSBzaWduaWZpY2F0aXZpZGFkIGRlIGxhIHByaW1lcmEgdmFyaWFibGUgZGUgaW50ZXJ2ZW5jacOzbiAoc2VndW5kbyBjb2VmaWNpZW50ZSBkZWwgbW9kZWxvKSwgdGVuZHLDrWFtb3MKYGBge3J9CndhbGQudGVzdChiID0gY29lZihhcmltYTEyMCksIAogICAgICAgICAgICAgICAgICBTaWdtYSA9IHZjb3YoYXJpbWExMjApLCAKICAgICAgICAgICAgICAgICAgVGVybXMgPSAyKQpgYGAKCkNvbiBhbGdvIG3DoXMgZGUgY8OzZGlnbyBzZSBwdWVkZSBjb21wcm9iYXIgcXVlIHRvZGFzIGxhcyB2YXJpYWJsZXMgc29uIHNpZ25pZmljYXRpdmFzLgoKYGBge3J9CmFuY2hvIDwtIG1heChuY2hhcihuYW1lcyhjb2VmKGFyaW1hMTIwKSkpKSArIDIKZm9yKGkgaW4gMTpsZW5ndGgoY29lZihhcmltYTEyMCkpKSB7CiAgd3QgPC0gd2FsZC50ZXN0KGIgPSBjb2VmKGFyaW1hMTIwKSwgCiAgICAgICAgICAgICAgICAgIFNpZ21hID0gdmNvdihhcmltYTEyMCksIAogICAgICAgICAgICAgICAgICBUZXJtcyA9IGkpCiAgY2F0KCJcbkNvZWZpY2llbnRlOiAiLCBmb3JtYXQobmFtZXMoY29lZihhcmltYTEyMCkpW2ldLCB3aWR0aCA9IGFuY2hvKSwgInZhbG9yIGRlIHA6ICIsIAogICAgICBmb3JtYXRDKHd0JHJlc3VsdCRjaGkyWzNdLCBkaWdpdHMgPSA0LCBmb3JtYXQgPSAiZiIpKQp9CmBgYAoKIyMjIEludGVydmVuY2nDs24gey19CgpMYSBmaWd1cmEgMTQgbXVlc3RyYSBxdWUgcGFyYSBuaW5nw7puIGHDsW8gc2Ugb2JzZXJ2YSB1biBlcnJvciBhdMOtcGljby4gU2kgc2UgaW5jbHV5ZSB1bmEgaW50ZXJ2ZW5jacOzbiBhc29jaWFkYSBhbCByZXNpZHVvIG3DoXMgZWxldmFkbyBlbiAxOTc0LCBubyByZXN1bHRhIHNpZ25pZmljYXRpdmEuCgpgYGB7cn0KZXJyb3IgPC0gcmVzaWR1YWxzKGFyaW1hMTIwKQpzZGVycm9yIDwtIHNkKGVycm9yKQoKYXV0b3Bsb3QoZXJyb3IsIHNlcmllcz0iRXJyb3IiLAogICAgICAgICBjb2xvdXIgPSAiYmxhY2siLAogICAgICAgICB4bGFiID0gIiIsCiAgICAgICAgIHlsYWIgPSAiRXJyb3IiLAogICAgICAgICBtYWluID0gIkZpZ3VyYSAxNC4gRXJyb3IgKyBJbnRlcnZlbmNpw7NuIikgKwogIGdlb21faGxpbmUoeWludGVyY2VwdCA9IGMoLTMsIC0yLCAyLCAzKSpzZGVycm9yLCAKICAgICAgICAgICAgIGNvbG91ciA9IGMoInJlZCIsICJncmVlbiIsICJncmVlbiIsICJyZWQiKSwgCiAgICAgICAgICAgICBsdHkgPSAyKSArIAogIGdlb21fcG9pbnQoKSArCiAgc2NhbGVfeF9jb250aW51b3VzKGJyZWFrcz0gc2VxKDE5NjAsIDIwMTQsIDQpKSAKYGBgCgpcCgojIyMgTWVkaWRhcyBkZSBlcnJvciB7LX0KCkVsIGVycm9yIG1lZGlvIGVzIGByIHJvdW5kKGFjY3VyYWN5KGFyaW1hMTIwKVsyXSwwKWAgbWlsZXMgZGUgdmVow61jdWxvcyAoUk1TRSkgeSBlbCBlcnJvciBwb3JjZW50dWFsIG1lZGlvIChNQVBFKSBlcyBgciByb3VuZChhY2N1cmFjeShhcmltYTEyMClbNV0sMilgJS4KCmBgYHtyLCBldmFsPUZBTFNFfQphY2N1cmFjeShhcmltYTEyMCkKYGBgCgpgYGB7cixlY2hvPUZBTFNFfQpyb3VuZChhY2N1cmFjeShhcmltYTEyMCksMikKYGBgCgojIyMgSW50ZXJwcmV0YWNpw7NuIGRlbCBtb2RlbG8gey19CgpFbCBfX21vZGVsbyB0ZcOzcmljb19fIGVzICRsb2coYWZvcm9fdCkgXHNpbSBBUklNQSgxLDIsMCkgKyBkMTk3OSArIGQxOTgxICsgZDkxODQgKyBkMjAxMSQ6CiQkKDEgLSBccGhpXzEgTCkoMSAtIEwpXjIgbG9nKGFmb3JvX3QpID0gIFx2YXJlcHNpbG9uX3QgKyBcZ2FtbWFfMSBcY2RvdCBkMTk3OSArIFxnYW1tYV8yIFxjZG90IGQxOTgxICsgXGdhbW1hXzMgXGNkb3QgZDE5ODQgKyBcZ2FtbWFfNCBcY2RvdCBkMjAxMS4kJAoKU2kgc3VzdGl0dWltb3MgJCgxIC0gTCleMiBsb2coYWZvcm9fdCkkIHBvciAkKDEgLSBMKSBUVkFhZm9yb190JCwgZG9uZGUgJFRWQWFmb3JvJCBlcyBsYSB0YXNhIGRlIHZhcmlhY2nDs24gYW51YWwgZGVsIGFmb3JvLCB5IGRlc2Fycm9sbGFtb3MsIHF1ZWRhOgokJFRWQWFmb3JvX3QgPSBUVkFhZm9yb197dC0xfSArIFxwaGlfMShUVkFhZm9yb197dC0xfS1UVkFhZm9yb197dC0yfSkgKyQkCiQkXGdhbW1hXzEgXGNkb3QgZDE5NzkgKyBcZ2FtbWFfMiBcY2RvdCBkMTk4MSArIFxnYW1tYV8zIFxjZG90IGQxOTg0ICsgXGdhbW1hXzQgXGNkb3QgZDIwMTEgKyBcdmFyZXBzaWxvbl90LiQkCgpGaW5hbG1lbnRlLiBlbCBfX21vZGVsbyBlc3RpbWFkb19fIGVzOgokJFx3aWRlaGF0e1RWQWFmb3JvfV90ID0gVFZBYWZvcm9fe3QtMX0gLTAuNjYoVFZBYWZvcm9fe3QtMX0tVFZBYWZvcm9fe3QtMn0pICsgJCQKJCQgLSAwLjE1IFxjZG90IGQxOTc5ICsgMC4wOCBcY2RvdCBkMTk4MSArIDAuMDggXGNkb3QgZDE5ODQgLSAwLjA5IFxjZG90IGQyMDExLiQkCkNhZGEgYcOxbyBsYSB0YXNhIGRlIHZhcmlhY2nDs24gZGVsIGFmb3JvIGVzIGVsIG1pc21hIHF1ZSBsYSBkZWwgYcOxbyBwYXNhZG8gbWVub3MgdW4gNjYlIGRlbCDDumx0aW1vIGluY3JlbWVudG8gZW50cmUgbGFzIHRhc2FzIGRlIHZhcmlhY2nDs24uCiAgICAKUmVzcGVjdG8gZGUgbGEgaW50ZXJ2ZW5jacOzbiwgZW4gMTk3OSBodWJvIHVuIDE1JSBtZW5vcyBkZSB2ZWjDrWN1bG9zIGRlIGxvIGVzcGVyYWRvLCBlbiAxOTgxIHkgMTk4NCBlbiB0b3JubyBhIHVuIDglIG3DoXMgeSBlbiAyMDExIHVuIDklIG1lbm9zLgogICAgICAKCiMjIyBQcmVkaWNjacOzbiB7LX0KCkNvbW8gaGVtb3MgaW5jbHVpZG8gY3VhdHJvIHZhcmlhYmxlcyBmaWN0aWNpYXMgZW4gZWwgYWp1c3RlLCBkZSBjYXJhIGEgcHJlZGVjaXIgZWwgYWZvcm8gaGVtb3MgZGUgaW5kaWNhciBjdWFsZXMgc2Vyw6FuIGxvcyB2YWxvcmVzIGZ1dHVyb3MgcGFyYSBlc3RhcyB2YXJpYWJsZXMuIEVuIGVzdGUgY2FzbyBzZXLDoW4gY2Vyb3MgcHVlc3RvIHF1ZSBzb24gaW50ZXJ2ZW5jaW9uZXMgcXVlIG5vIHJlc3BvbmRlbiBhIGVmZWN0b3MgY2FsZW5kYXJpby4KICAKRW4gYFJgIGVzdG8gc2UgaGFjZSBpbmNsdXllbmRvIGVuIGVsIGNvbWFuZG8gYGZvcmVjYXN0YCBlbCBhcmd1bWVudG8gYHhyZWcgPSBjYmluZChyZXAoMCwgNSksIHJlcCgwLCA1KSwgcmVwKDAsIDUpLCByZXAoMCwgNSkpYCBxdWUgYcOxYWRlIGNpbmNvIGNlcm9zIHBvciBjYWRhIHZhcmlhYmxlIGRlIGludGVydmVuY2nDs24gcG9ycXVlIGxhIHByZWRpY2Npw7NuIHZhIGEgc2VyIGEgY2luY28gYcOxb3MgdmlzdGEuCgpgYGB7cn0KcGFyaW1hMTIwIDwtIGZvcmVjYXN0KGFyaW1hMTIwLCAKICAgICAgICAgICAgICAgICAgICAgIGggPSA1LCAKICAgICAgICAgICAgICAgICAgICAgIGxldmVsID0gOTUsCiAgICAgICAgICAgICAgICAgICAgICB4cmVnID0gY2JpbmQoZDE5Nzk9cmVwKDAsIDUpLCBkMTk4MT1yZXAoMCwgNSksIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQxOTg0PXJlcCgwLCA1KSwgZDIwMTE9cmVwKDAsIDUpKSkKcGFyaW1hMTIwCmBgYAoKYGBge3J9CmF1dG9wbG90KHBhcmltYTEyMCwgCiAgICAgeWxhYiA9ICdWZWjDrWN1bG9zICgwMDApJywKICAgICBtYWluID0gJ0ZpZ3VyYSAxNS4gQWZvcm8gKDE5NjAtMjAxOCkgeSBwcmVkaWNjacOzbiAoMjAxOS0yMDIzKScpICsKICBzY2FsZV94X2NvbnRpbnVvdXMoYnJlYWtzPSBzZXEoMTk2MCwgMjAyMywgNCkpIApgYGAKClwKCiMjIEFmb3JvIGRlIHZlaMOtY3Vsb3MgcmV2aXNhZG8KClZhbW9zIGEgdm9sdmVyIGEgaWRlbnRpZmljYXIgZWwgKm1lam9yKiBtb2RlbG8gQVJJTUEgcGFyYSBsYSBzZXJpZSBBZm9ybywgcGVybyBjYW1iaWFuZG8gZWwgZW5mb3F1ZS4gTGEgZnVuY2nDs24gZGUgYXV0b2lkZW50aWZpY2FjacOzbiB1c2EgY29tbyBjcml0ZXJpbyBkZSBvcHRpbWFsaWRhZCB1biBjcml0ZXJpbyBkZSBhanVzdGUgKEFJQywgQklDKS4gU2kgbG8gcXVlIGRlc2VhbW9zIGVzIGlkZW50aWZpY2FyIGVsIG1vZGVsbyBjb24gbWVqb3JlcyBwcmVkaWNjaW9uZXMgZXh0cmEtbXVlc3RyYWxlcywgaGF5IHF1ZSBwcm9jZWRlciBkZSBvdHJhIGZvcm1hLiBWYW1vcyBzZWxlY2Npb25hciB1biBjb25qdW50byBhbXBsaW8gZGUgbW9kZWxvcywgdmFtb3MgYSBlc3RpbWFyIGNhZGEgdW5vIGRlIGVsbG9zIHkgdmFtb3MgYSBjYWxjdWxhciBlbCBlcnJvciAoTUFQRSkgcGFyYSBwcmV2aXNvbmVzIGV4dHJhLW11ZXN0cmFsZXMgc2Vnw7puIGVsIGhvcml6b250ZSB0ZW1wb3JhbC4gRWwgbWVqb3IgbW9kZWxvIHNlcsOhIGVsIHF1ZSBjb21ldGEgbWVub3IgZXJyb3IgZGUgcHJldmlzacOzbiBwYXJhIGVsIGhvcml6b250ZSB0ZW1wb3JhbCBuZWNlc2FyaW8uCgpFbCBzaWd1aWVudGUgY8OzZGlnbyBkZWZpbmUgdW4gdG90YWwgZGUgOTYgbW9kZWxvcywgcmVzdWx0YWRvIGRlIGxhIGNvbWJpbmFjacOzbiBkZSBsb3MgcG9zaWJsZXMgdmFsb3JlcyBkZWwgb3JkZW4gYXV0b3JlZ3Jlc2l2byAkcCA9IDAsIDEsIDIsIDMkOyBlbCBuw7ptZXJvIGRlIGRpZmVyZW5jaWFjaW9uZXMgJGQgPSAwLCAxLCAyJDsgbG9zIHBvc2libGVzIHZhbG9yZXMgZGVsIG9yZGVuIGVuIG1lZGlhcyBtw7N2aWxlcyAkcSA9IDAsIDEsIDIsIDMkIHkgZWwgdXNvIGRlIGxhIHRyYW5zZm9ybWFjacOzbiBsb2dhcsOtdG1pY2EgKHPDrS9ubykuIAoKUG9yIHNpbXBsaWNpZGFkLCBoZW1vcyBhc3VtaWRvIHF1ZSBlbCBtb2RlbG8gbm8gdGllbmUgY29uc3RhbnRlIHkgbm8gaGVtb3MgaW5jbHVpZG8gbGEgaW50ZXJ2ZW5jacOzbi4KClBvciBkZWZlY3RvLCBsYSBmdW5jacOzbiBgQXJpbWFgIHNvbG8gZXN0aW1hIG1vZGVsb3MgZXN0YWNpb25hcmlvcy4gUGFyYSBlbHVkaXIgZXN0YSByZXN0cmljY2nDs24geSBxdWUgZXN0aW1lIGN1YWxxdWllciBtb2RlbG8sIHNlYSBvIG5vIGVzdGFjaW9uYXJpbywgaGVtb3MgaW5jbHVpZG8gZWwgYXJndW1lbnRvIGBtZXRob2QgPSAiTUwiYC4KCgpgYGB7cn0KcCA8LSAwOjMKZCA8LSAwOjIKcSA8LSAwOjMKbCA8LSAwOjEKcGFyYW1ldHJvcyA8LSBleHBhbmQuZ3JpZChwLGQscSxsKQpjb2xuYW1lcyhwYXJhbWV0cm9zKSA8LSBjKCJwIiwgImQiLCAicSIsICJsb2ciKQoKayA8LSA0MCAgICAgICAgICAgICAgICAgI01pbmltbyBudW1lcm8gZGUgZGF0b3MgcGFyYSBlc3RpbWFyCmggPC0gIDUgICAgICAgICAgICAgICAgICNIb3Jpem9udGUgZGUgbGFzIHByZWRpY2ljb25lcwpUVCA8LSBsZW5ndGgoYWZvcm8pICAgICAjTG9uZ2l0dWQgc2VyaWUKcyA8LSBUVCAtIGsgLSBoICAgICAgICAgI1RvdGFsIGRlIGVzdGltYWNpb25lcwoKTUFQRSA8LSBtYXRyaXgoTkEsIG5yb3cocGFyYW1ldHJvcyksIGgpCgpmb3IgKHBhcmEgaW4gMTpucm93KHBhcmFtZXRyb3MpKSB7CgogIGlkZW50aWZpY2FjaW9uIDwtIGFzLm51bWVyaWMocGFyYW1ldHJvc1twYXJhLCAtIDRdKQogIG1hcGVBcmltYSA8LSBtYXRyaXgoTkEsIHMgKyAxLCBoKQogIGZvciAoaSBpbiAwOnMpIHsKICAgIHRyYWluLnNldCA8LSBzdWJzZXQoYWZvcm8sIHN0YXJ0ID0gaSArIDEsIGVuZCA9IGkgKyBrKQogICAgdGVzdC5zZXQgPC0gIHN1YnNldChhZm9ybywgc3RhcnQgPSBpICsgayArIDEsIGVuZCA9IGkgKyBrICsgaCkKICAgIAogICAgaWYocGFyYW1ldHJvc1twYXJhLCA0XSA9PSAwKSAKICAgICAgZml0IDwtIEFyaW1hKHRyYWluLnNldCwgb3JkZXIgPSBpZGVudGlmaWNhY2lvbiwgbWV0aG9kID0gIk1MIikgZWxzZSAKICAgICAgICAgICAgICAgICAgICAgZml0IDwtIEFyaW1hKHRyYWluLnNldCwgb3JkZXIgPSBpZGVudGlmaWNhY2lvbiwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGEgPSAwLCBtZXRob2QgPSAiTUwiKQogICAgZmNhc3QgPC0gZm9yZWNhc3QoZml0LCBoID0gaCkKICAgIG1hcGVBcmltYVtpICsgMSxdIDwtIDEwMCphYnModGVzdC5zZXQgLSBmY2FzdCRtZWFuKS90ZXN0LnNldAogIH0KICAKICBNQVBFW3BhcmEsIF0gPC0gY29sTWVhbnMobWFwZUFyaW1hKQoKfQoKIyBNZWpvcmVzIG1vZGVsb3Mgc2kgaCA9IDEKaWkgPC0gb3JkZXIoTUFQRVssIDFdLCBkZWNyZWFzaW5nID0gRkFMU0UpCmNiaW5kKHBhcmFtZXRyb3NbaWlbMTozXSxdLCBlcnJvciA9IHJvdW5kKE1BUEVbaWlbMTozXSwgMV0sIDMpKQoKIyBNZWpvcmVzIG1vZGVsb3Mgc2kgaCA9IDIKaWkgPC0gb3JkZXIoTUFQRVssIDJdLCBkZWNyZWFzaW5nID0gRkFMU0UpCmNiaW5kKHBhcmFtZXRyb3NbaWlbMTozXSxdLCBlcnJvciA9IHJvdW5kKE1BUEVbaWlbMTozXSwgMl0sIDMpKQoKIyBNZWpvcmVzIG1vZGVsb3Mgc2kgaCA9IDMKaWkgPC0gb3JkZXIoTUFQRVssIDNdLCBkZWNyZWFzaW5nID0gRkFMU0UpCmNiaW5kKHBhcmFtZXRyb3NbaWlbMTozXSxdLCBlcnJvciA9IHJvdW5kKE1BUEVbaWlbMTozXSwgM10sIDMpKQoKIyBNZWpvcmVzIG1vZGVsb3Mgc2kgaCA9IDQKaWkgPC0gb3JkZXIoTUFQRVssIDRdLCBkZWNyZWFzaW5nID0gRkFMU0UpCmNiaW5kKHBhcmFtZXRyb3NbaWlbMTozXSxdLCBlcnJvciA9IHJvdW5kKE1BUEVbaWlbMTozXSwgNF0sIDMpKQoKIyBNZWpvcmVzIG1vZGVsb3Mgc2kgaCA9IDUKaWkgPC0gb3JkZXIoTUFQRVssIDVdLCBkZWNyZWFzaW5nID0gRkFMU0UpCmNiaW5kKHBhcmFtZXRyb3NbaWlbMTozXSxdLCBlcnJvciA9IHJvdW5kKE1BUEVbaWlbMTozXSwgNV0sIDMpKQpgYGAKCkxhcyB0YWJsYXMgaWRlbnRpZmljYW4gbG9zIHRyZXMgbWVqb3JlcyBtb2RlbG9zIHNlZ8O6biBxdWUgZWwgb3JkZW4gZGUgcHJldmlzacOzbiBkZSBpbnRlcsOpcywgZGVzZGUgdW5vIGEgY2luY28gYcOxb3MuCgoqIFBhcmEgcHJldmlzaW9uZXMgYSB1biBhw7FvIHZpc3RhIGVsIG1lam9yIG1vZGVsbyBlcyAkbG9nKEFmb3JvX3QpIFxzaW0gQVJJTUEoMiwxLDIpJC4gQXVucXVlIGxvcyBvdHJvcyBkb3MgbW9kZWxvcyBtb3N0cmFkb3MgcmVzdWx0YW4gZXF1aXZhbGVudGVzLgoqIFBhcmEgcHJldmlzaW9uZXMgYSBtw6FzIGRlIHVuIGHDsW8gdmlzdGEgZWwgbWVqb3IgbW9kZWxvIGVzICRsb2coQWZvcm9fdCkgXHNpbSBBUklNQSgyLDAsMykkLCBlbiBvY2FzaW9uZXMgbXV5IHN1cGVyaW9yIGFsIHNpZ3VpZW50ZSBfbWVqb3JfIG1vZGVsby4KKiBOaW5ndW5vIGRlIGxvcyBtb2RlbG8gcXVlIG1lam9yZXMgcHJlZGljY2lvbmVzIGdlbmVyYW4gZXMgZWwgcXVlIG1lam9yIGFqdXN0YSBhIGxvcyBkYXRvcy4KCgpcCgojIyBDb25zdW1vIGRlIGFsaW1lbnRvcyBlbiBlbCBob2dhciBwZXIgY8OhcGl0YQoKQW5hbGl6YXJlbW9zIGVsIF9fY29uc3VtbyBhbGltZW50YXJpbyBlbiBob2dhciBwZXIgY8OhcGl0YV9fIGVuIEVzcGHDsWEuIEVzdGEgc2VyaWUgZXN0w6EgY29uc3RydWlkYSBhIHBhcnRpciBkZSBsYSBzZXJpZSBkZSBjb25zdW1vIGFsaW1lbnRhcmlvIGVuIGhvZ2FyIChkaXNwb25pYmxlIGVuIGVsIE1pbmlzdGVyaW8gZGUgQWdyaWN1bHR1cmEsIEFsaW1lbnRhY2nDs24geSBNZWRpbyBBbWJpZW50ZSksIHkgbGEgc2VyaWUgZGUgcG9ibGFjacOzbiAoZGlzcG9uaWJsZSBlbiBlbCBJbnN0aXR1dG8gTmFjaW9uYWwgZGUgRXN0YWTDrXN0aWNhKS4gRXMgdW5hIHNlcmllIGFudWFsIGRlIDE5ODcgYSAyMDE4ICgzMiBkYXRvcykgeSBsYSB1bmlkYWQgZXMgZWwgS2cgcGVyIGPDoXBpdGEuIExhIGZpZ3VyYSAyMyBtdWVzdHJhIHF1ZSBlcyB1bmEgc2VyaWUgbXV5IGlycmVndWxhciwgY29uIGNhbWJpb3MgZGUgdGVuZGVuY2lhIGNvbnN0YW50ZXMuCgpgYGB7cn0KYWxpbWVudG9zcGMgPC0gcmVhZC5jc3YyKCIuL3Nlcmllcy9hbGltZW50YWNpb25wYy5jc3YiLCBoZWFkZXIgPSBUUlVFKQphbGltZW50b3NwYyA8LSB0cyhhbGltZW50b3NwYywgc3RhcnQgPSAxOTg3LCBmcmVxID0gMSkKICAgIAphdXRvcGxvdChhbGltZW50b3NwYywgCiAgICAgICAgIHhsYWIgPSAiIiwgCiAgICAgICAgIHlsYWIgPSAiS2cgcGVyIGPDoXBpdGEiLAogICAgICAgICBtYWluID0gIkZpZ3VyYSAxNi4gQ29uc3VtbyBhbGltZW50YXJpbyBlbiBob2dhciIpCmBgYAoKIyMjIFRyYW5zZm9ybWFjacOzbiBkZSBsYSBzZXJpZSB7LX0KCkxhIGZpZ3VyYSAxNyBpbmRpY2EgcXVlIGxhIHNlcmllIG9yaWdpbmFsIHlhIGVzIGVzdGFjaW9uYXJpYSB5IGxhIGZ1bmNpw7NuIGBuZGlmZnNgIGxvIGNvcnJvYm9yYS4gUG9yIHRhbnRvIGFzdW1pbW9zIHF1ZSAkZD0wJCBvICRhbGltZW50b3NwY190IFxzaW0gSSgwKSQuCgpgYGB7ciwgZXZhbCA9IEZBTFNFfQphdXRvcGxvdChhbGltZW50b3NwYywgeGxhYiA9ICIiLCB5bGFiID0gIiIsIG1haW4gPSAiQWxpbWVudG9zIikKYXV0b3Bsb3QoZGlmZihhbGltZW50b3NwYyksIHhsYWIgPSAiIiwgeWxhYiA9ICIiLCBtYWluID0gIkRpZmVyZW5jaWEgYWxpbWVudG9zIikKZ2dBY2YoYWxpbWVudG9zcGMsIHhsYWIgPSAiIiwgeWxhYiA9ICJGQUMiLCBtYWluID0gIiIpCmdnQWNmKGRpZmYoYWxpbWVudG9zcGMpLCB4bGFiID0gIiIsIHlsYWIgPSAiRkFDIiwgbWFpbiA9ICIiKQpgYGAKCmBgYHtyLCBlY2hvID0gRkFMU0V9CmdyaWQuYXJyYW5nZSgKICBhdXRvcGxvdChsb2coYWxpbWVudG9zcGMpLCB4bGFiID0gIkFsaW1lbnRvcyIsIHlsYWIgPSAiIiwgbWFpbiA9ICJGaWd1cmEgMTcuIENvbnN1bW8gZGUgYWxpbWVudG9zIiksCiAgYXV0b3Bsb3QoZGlmZihsb2coYWxpbWVudG9zcGMpKSwgeGxhYiA9ICJEaWZlcmVuY2lhIGRlIGFsaW1lbnRvcyIsIHlsYWIgPSAiIiwgbWFpbiA9ICIiKSwKICBnZ0FjZihsb2coYWxpbWVudG9zcGMpLCB4bGFiID0gIiIsIHlsYWIgPSAiRkFDIiwgbWFpbiA9ICIiKSwKICBnZ0FjZihkaWZmKGxvZyhhbGltZW50b3NwYykpLCB4bGFiID0gIiIsIHlsYWIgPSAiRkFDIiwgbWFpbiA9ICIiKSwKICBucm93ID0gMgopCmBgYAoKIyMjIElkZW50aWZpY2FjacOzbiB7LX0KClBhcmEgaWRlbnRpZmljYXIgbG9zIHZhbG9yZXMgZGUgJHAkIHkgJHEkIHZlcmVtb3MgcXVlIG5vcyBzdWdpZXJlIGBhdXRvLmFyaW1hYCA6CgpgYGB7cn0gCmF1dG8uYXJpbWEoYWxpbWVudG9zcGMpCmBgYAoKTGEgaWRlbnRpZmljYWNpw7NuIGF1dG9tw6F0aWNhIHN1Z2llcmUgdW4gcHJvY2VzbyBBUigxKSBjb24gY29uc3RhbnRlIHkgYW1ib3MgY29lZmljaWVudGVzIHBhcmVjZW4gc2lnbmlmaWNhdGl2b3MuCgpWYW1vcyBhIHZlciBsYSBncsOhZmljYSBkZSBsb3MgcmVzaWR1b3MgZGUgZXN0ZSBwcm9jZXNvIHBhcmEgaWRlbnRpZmljYXIgcsOhcGlkYW1lbnRlIHNpIGhheSB2YWxvcmVzIGV4dHJlbW9zIChmaWd1cmEgMTgpLgoKCmBgYHtyfQphcmltYTEwMCA8LSBBcmltYShhbGltZW50b3NwYywgCiAgICAgICAgICAgICAgICAgIG9yZGVyID0gYygxLCAwLCAwKSkKCmVycm9yIDwtIHJlc2lkdWFscyhhcmltYTEwMCkKc2RlcnJvciA8LSBzZChlcnJvcikKCmF1dG9wbG90KGVycm9yLCBzZXJpZXM9IkVycm9yIiwKICAgICAgICAgY29sb3VyID0gImJsYWNrIiwKICAgICAgICAgeGxhYiA9ICIiLAogICAgICAgICB5bGFiID0gIkVycm9yIiwKICAgICAgICAgbWFpbiA9ICJGaWd1cmEgMTguIEVycm9yICsgSW50ZXJ2ZW5jacOzbiIpICsKICBnZW9tX2hsaW5lKHlpbnRlcmNlcHQgPSBjKC0zLCAtMiwgMiwgMykqc2RlcnJvciwgCiAgICAgICAgICAgICBjb2xvdXIgPSBjKCJyZWQiLCAiZ3JlZW4iLCAiZ3JlZW4iLCAicmVkIiksIAogICAgICAgICAgICAgbHR5ID0gMikgKyAKICBnZW9tX3BvaW50KCkgKwogIHNjYWxlX3hfY29udGludW91cyhicmVha3M9IHNlcSgxOTg3LCAyMDE4LCAzKSkgCmBgYAoKTmluZ8O6biByZXNpZHVvIHN1cGVyYSBsYXMgMi41IGRlc3ZpYWNpb25lcyB0w61waWNhcyBhc8OtIHF1ZSBjb25zaWRlcmFyZW1vcyBxdWUgJGFsaW1lbnRvc3BjX3QgXHNpbSBBUklNQSgxLDAsMCkkLgoKIyMjIENvZWZpY2llbnRlcyBzaWduaWZpY2F0aXZvcyB7LX0KClRhbnRvICRccGhpXzEkIGNvbW8gJFxtdSQgKGxhIGNvbnN0YW50ZSBkZWwgbW9kZWxvKSBzb24gc2lnbmlmaWNhdGl2b3MuCgpgYGB7cn0Kd2FsZC50ZXN0KGIgPSBjb2VmKGFyaW1hMTAwKSwgU2lnbWEgPSB2Y292KGFyaW1hMTAwKSwgVGVybXMgPSAxKQp3YWxkLnRlc3QoYiA9IGNvZWYoYXJpbWExMDApLCBTaWdtYSA9IHZjb3YoYXJpbWExMDApLCBUZXJtcyA9IDIpCmBgYAoKIyMjIE1lZGlkYXMgZGUgZXJyb3Igey19CgpFbCBlcnJvciBtZWRpbyBlcyBgciByb3VuZChhY2N1cmFjeShhcmltYTEwMClbMl0sMClgIEtnIHBlciBjw6FwaXRhIChSTVNFKSB5IGVsIGVycm9yIHBvcmNlbnR1YWwgbWVkaW8gKE1BUEUpIGVzIGByIHJvdW5kKGFjY3VyYWN5KGFyaW1hMTAwKVs1XSwyKWAlLgoKYGBge3IsIGV2YWw9RkFMU0V9CmFjY3VyYWN5KGFyaW1hMTAwKQpgYGAKCmBgYHtyLGVjaG89RkFMU0V9CnJvdW5kKGFjY3VyYWN5KGFyaW1hMTAwKSwyKQpgYGAKCiMjIyBJbnRlcnByZXRhY2nDs24gZGVsIG1vZGVsbyB7LX0KCkVsIF9fbW9kZWxvIHRlw7NyaWNvX18gaWRlbnRpZmljYWRvIGVzICRhbGltZW50b3NwY190IFxzaW0gQVJJTUEoMSwwLDApJCArIGNvbnN0YW50ZToKJCQoMSAtIFxwaGlfMSBMKSBhbGltZW50b3NwY190ID0gYyArIFx2YXJlcHNpbG9uX3QsJCQKCnF1ZSBkZXNhcnJvbGxhbmRvIHF1ZWRhOgokJGFsaW1lbnRvc3BjX3QgPSBjICsgXHBoaV8xIGFsaW1lbnRvc3BjX3t0LTF9KyBcdmFyZXBzaWxvbl90LiQkCgpGaW5hbG1lbnRlLiBlbCBfX21vZGVsbyBlc3RpbWFkb19fIGVzOgokJFx3aWRlaGF0e2FsaW1lbnRvc3BjfV90ID0gMjI1LjIxICsgMC42NSBcY2RvdCBhbGltZW50b3NwY197dC0xfSQkCgpfX09ic2VydmFjacOzbl9fOiBFbCB0w6lybWlubyBjb250YW50ZSAkXG11JCBxdWUgZXN0aW1hIFIgbm8gZWwgdmFsb3IgZGUgImMiIHF1ZSBoZW1vcyB2aXN0byBlbiBsYSB0ZW9yw61hLiBQYXJhIGNvbnZlcnRpciBsYSBjb250YW50ZSBlc3RpbWFkYSBwb3IgUiBlbiAiYyIgaGVtb3MgZGUgbXVsdGlwbGljYXJsYSBwb3IgZWwgcG9saW5vbWlvIGF1dG9yZWdyZXNpdm8uIEVuIGVzdGUgY2FzbywKJCRjID0gXG11IFxjZG90ICgxIC0gXHBoaV8xKSA9IDYzOS4yNTEyXGNkb3QoMSAtIDAuNjQ3NykgPSAyMjUuMjA4Mi4kJAoKQ2FkYSBhw7FvIGVsIGNvbnN1bW8gZGUgYWxpbWVudG9zIHBlciBjw6FwaXRhIGVuIGVsIGhvZ2FyIGVzIDIyNSBraWxvcyBtw6FzIHVuIDY1JSBkZWwgY29uc3VtbyBkZWwgYcOxbyBwYXNhZG8uCgojIyMgUHJlZGljY2lvbmVzIGRlIGxhIHNlcmllIHstfQoKCmBgYHtyfQpwYXJpbWExMDAgPC0gZm9yZWNhc3QoYXJpbWExMDAsIGggPSA1LCBsZXZlbCA9IDk1KQpwYXJpbWExMDAKYGBgCgpQdWVkZXMgY29tcHJvYmFyIHF1ZSBjYWRhIHZhbG9yIGRlIGxhIHByZWRpY2Npw7NuIHNlIGhhIG9idGVuaWRvIGEgcGFydGlyIGRlbCBtb2RlbG8gZXN0aW1hZG8sIGRvbmRlICRhbGltZW50b3NwY197dC0xfSQgc2Ugc3VzdGl0dXllIHBvciBsYSBwcmVkaWNjacOzbiBkZWwgYcOxbyBwcmVjZWRlbnRlLgoKYGBge3J9CmF1dG9wbG90KHBhcmltYTEwMCwgCiAgICAgeWxhYiA9ICJLaWxvcyBwZXIgY8OhcGl0YSIsCiAgICAgbWFpbiA9ICJGaWd1cmEgMTkuIENvbnN1bW8gZGUgYWxpbWVudG9zIHkgcHJlZGljY2nDs24iKSArCiAgc2NhbGVfeF9jb250aW51b3VzKGJyZWFrcz0gc2VxKDE5ODcsIDIwMjMsIDQpKSAKYGBgCgpcCgojIyBDb21wYXJhY2nDs24gY29uIGFsaXNhZG8gZXhwb25lbmNpYWwKClZlYW1vcyB1bmEgY29tcGFyYXRpdmEsIHBhcmEgbG9zIHRyZXMgZWplbXBsb3MgdmlzdG9zLCBlbnRyZSBsb3MgcmVzdWx0YWRvcyBvYnRlbmlkb3MgY29uIEFSSU1BIHkgY29uIEFsaXNhZG8gZXhwb25lbmNpYWwuCiAgCiogTGlicm9zOgogICAgKyBNQVBFIEFSSU1BOiAkNy4wMlwlJCAtIEFSSU1BKDAsMSwwKSBzaW4gZGVyaXZhCiAgICAKICAgICsgTUFQRSBFVFM6ICAgJDcuMDVcJSQgLSBFVFMoTSxOLE4pLCAkXGFscGhhPTEkCiAgICAKICAgICsgQW1ib3MgbcOpdG9kb3MgaGFuIGVzdGltYWRvIGVsIG1pc21vIG1vZGVsby4KClx2c3BhY2V7LjVjbX0KCiogQWZvcm8gKGxvZyk6CiAgICArIE1BUEUgQVJJTUE6ICQ1LjI0XCUkIC0gQVJJTUEoMSwyLDApIHNpbiBkZXJpdmEsIGNvbiBpbnRlcnZlbmNpw7NuCiAgICAKICAgICsgTUFQRSBFVFM6ICAgJDUuNzNcJSQgLSBFVFMoQSxBZCxOKSwgJFxhbHBoYT0wLjU3JCwgJFxiZXRhPTAuNTckLCAkXHBoaSA9IDAuODUkCiAgICAKICAgICsgQ2FkYSBtw6l0b2RvIGVzdGltYSB1biBtb2RlbG8gZGlmZXJlbnRlCiAgICAKICAgICsgQVJJTUEgdGllbmUgbWVub3IgZXJyb3IgYSBjb3N0YSBkZSBpbmNsdWlyIGN1YXRybyB2YXJpYWJsZXMgZGUgaW50ZXJ2ZW5jacOzbgoKXHZzcGFjZXsuNWNtfQoKKiBBbGltZW50b3MgcGVyIGPDoXBpdGE6CiAgICArIE1BUEUgQVJJTUE6ICQxLjM3JCAtIEFSSU1BKDEsMCwwKSBjb24gY29uc3RhbnRlCiAgICAKICAgICsgTUFQRSBFVFM6ICAgJDEuNDMkIC0gRVRTKE0sTixOKSwgJFxhbHBoYSA9IDEkCiAgICAKICAgICsgQ2FkYSBtw6l0b2RvIGhhIGVzdGltYWRvIHVuIG1vZGVsbyBkaWZlcmVudGUsIHBlcm8gY29uIHVuYSBib25kYWQgZGUgYWp1c3RlIHNpbWlsYXIuCgoKXApcCgojIFJlc3VtZW4gZGUgbG9zIGNvbWFuZG9zIHV0aWxpemFkb3MKCgp8RnVuY2nDs24gICAgICAgIHxQYXF1ZXRlICAgICAgICAgfERlc2NyaXBjacOzbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwKfDotLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwKfGBBcmltYWAgICAgICAgIHxmb3JlY2FzdCAgfGVzdGltYSB1biBwcm9jZXNvIEFSSU1BIHwKfGBhdXRvLmFyaW1hYCAgIHxmb3JlY2FzdCAgfGlkZW50aWZpY2FjacOzbiBhdXRvbcOhdGljYSBkZSB1biBtb2RlbG8gQVJJTUEgICAgICAgICAgfAp8YHdhbGQudGVzdGAgICAgfGFvZCAgICB8Y29udHJhc3RhIGxhIHNpZ25pZmljYXRpdmlkYWQgY29uanVudGEgZGUgdmFyaW9zIHBhcsOhbWV0cm9zfAp8YGZvcmVjYXN0YCAgICAgfGZvcmVjYXN0ICB8cmVhbGl6YSB1bmEgcHJlZGljY2nDs24gZGUgdW4gbW9kZWxvfAoKXApcCgojIFJlZmVyZW5jaWFzCgoqIEJveCwgRy4gRS5QLiB5IEplbmtpbnMsIEcuICgxOTc2KS4gX1RpbWUgU2VyaWVzIEFuYWx5c2lzOiBGb3JlY2FzdGluZyBhbmQgQ29udHJvbF8gIEVkaXRhZG8gcG9yIEhvbGRlbi1EYXksIFNhbiBGcmFuY2lzY28sIENBCgpcClwKXApcCgoK</div>
<footer class="footer">
  
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
<br>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.  <div class="text-muted">Website created by Iv&aacute;n Arribas. &copy;  2020. If you find any bugs please report them to <a href="mailto:ivan.arribas@uv.es"> ivan.arribas@uv.es</a>.</div>
  
</footer>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("03-06-Tema6.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
